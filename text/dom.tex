\chapter{Einführung in die App}
\label{intro_app}
\renewcommand{\kapitelautor}{Autor: Josip Domazet}

Das Ziel der Diplomarbeit ist es, eine App zu entwickeln, mit der man in
der Lage ist, eine Inventur durchzuführen. Um zu verstehen, wieso sich
das Projektteam für eine native App entschieden hat, muss man zwischen
zwei Begriffen unterscheiden \cite{native-vs-web}:

\begin{itemize}
\tightlist
\item
  Native App
\item
  Web-App
\end{itemize}

\hypertarget{nativ-versus-web}{%
\section{Nativ versus Web}\label{nativ-versus-web}}

Unter einer nativen App versteht man eine App, die für ein bestimmtes
Betriebssystem geschrieben wurde \cite{native-definition}. Eine Web-App
hingegen basiert auf HTML und wird per Browser aufgerufen. Sie stellt
nichts anderes als eine für mobile Geräte optimierte Website dar.

\hypertarget{begruxfcndung-fuxfcr-die-wahl-der-nativen-app}{%
\section{Begründung für die Wahl der nativen
App}\label{begruxfcndung-fuxfcr-die-wahl-der-nativen-app}}

Das Projektteam hat sich für eine native App entschieden. Um diese
Entscheidung nachvollziehen zu können, ist ein tieferer Einblick in den
gegebenen Use-Case erforderlich.

Das Ziel ist es nicht, möglichst viele Downloads im Play Store zu
erzielen oder etwaige Marketingmaßnahmen zu setzen. Es soll stattdessen
mit den gegebenen Ressourcen eine Inventurlösung entwickelt werden, die
die bestmögliche Lösung für die vorliegende Schule darstellt. Eine
native App wird eine Web-App hinsichtlich Qualität und User Experience
immer klar übertreffen.

Im vorliegenden Fall wäre es sicherlich möglich, eine Inventur mittels
Web-App durchzuführen, allerdings würde diese vor allem in den Bereichen
Performanz und Verlässlichkeit Mängel aufweisen. Diese zwei Bereiche
stellen genau die zwei Problembereiche dar, die es mit der vorliegenden
Gesamtlösung bestmöglich zu optimieren gilt. Des Weiteren bieten sich
native Apps ebenfalls für komplexe Projekte an, da Web-Apps aktuell noch
nicht in der Lage sind, komplexe Aufgabenstellungen mit vergleichbar
geringem Aufwand zu inkorporieren \cite{complex-article}. Die
vorliegende Arbeit ist dabei bereits allein aufgrund der in Betracht zu
ziehenden Sonderfälle als komplexe Aufgabenstellung einzustufen.

Unter Berücksichtigung dieser Gesichtspunkte wurde also der Entschluss
gefasst, eine native Applikation zu entwickeln, da diese ein insgesamt
besseres Produkt darstellen wird. Es sei gesagt, dass es auch hybride
Apps gibt. Diese sind jedoch einer nativen App in denselben Aspekten wie
eine Web-App klar unterlegen.

\hypertarget{auswahl-der-nativen-technologie}{%
\subsection{Auswahl der nativen
Technologie}\label{auswahl-der-nativen-technologie}}

Folgende native Alternativen waren zu vergleichen:

\begin{itemize}
\tightlist
\item
  Flutter \cite{flutter}
\item
  Xamarin \cite{xamarin}
\item
  Native IOS
\item
  Native Android (Java/Kotlin)
\end{itemize}

Flutter ist ein von Google entwickeltes Framework, dass eine gemeinsame
Codebasis für Android und IOS anbietet. Eine gemeinsame Codebasis wird
oftmals unter dem Begriff \texttt{cross-platform} zusammengefasst und
bedeutet, dass man eine mit Flutter entwickelte native App sowohl mit
Android-Geräten als auch mit IOS-Geräten verwenden kann. Flutter ist
eine relativ neue Plattform -- die erste stabile Version wurde erst im
Dezember 2018 veröffentlicht \cite{flutter-stable}. Außerdem verwendet
Flutter die Programmiersprache \texttt{Dart}, die Java ähnelt. Diese
Umstände sind ein Segen und Fluch zugleich. Flutter wird in Zukunft
sicherlich weiterhin an Popularität zulegen, allerdings ist die Anzahl
an verfügbarer Dokumentation für das junge Flutter im Vergleich zu den
anderen Optionen immer noch weitaus geringer.

Xamarin ist ebenfalls ein cross-platform Framework, das jedoch in C\#
geschrieben wird und älter (und damit bewährter) als Flutter ist.
Weiters macht Xamarin von der proprietären .NET-Platform Gebrauch.
Infolgedessen haben alle Xamarin-Apps Zugriff auf ein umfassendes
Repertoire von .NET-Libraries \cite{xamarin-details}. Da Xamarin und
.NET Microsoft angehören, ist eine leichtere Azure-Integration oftmals
ein Argument, das von offzielen Quellen verwendet wird. Xamarin wird --
anders als die restlichen Optionen -- bevorzugterweise in Visual Studio
entwickelt \cite{xamarin-vs}.

Native IOS wird nur der Vollständigkeit halber aufgelistet, stellte
allerdings zu keinem Zeitpunkt eine wirkliche Alternative dar, weil
IOS-Geräte einige Eigenschaften besitzen, die für eine Inventur nicht
optimal sind (\zB die Akkukapazität). Außerdem haben in etwa nur 20\%
aller Geräte \cite{ios-market-share} IOS als Betriebssystem und die
Entwicklung einer IOS-App wird durch strenge Voraussetzungen äußerst
unattraktiv gemacht. So kann man beispielsweise nur auf einem
Apple-Gerät IOS-Apps entwickeln.

\hypertarget{begruxfcndung-natives-android-java}{%
\subsubsection{Begründung: Natives Android
(Java)}\label{begruxfcndung-natives-android-java}}

Die Entscheidung ist schlussendlich auf natives Android (Java) gefallen.
Es mag zwar vielleicht nicht die innovativste Entscheidung sein, stellt
aber aus folgenden Gründen die bewährteste und risikoloseste Option dar:

\begin{itemize}
\tightlist
\item
  Natives Android ist eine allbekannte und weit etablierte Lösung. Die
  Wahrscheinlichkeit, dass die Unterstützung durch Google eingestellt
  wird, ist also äußerst gering.
\item
  Die App wird in den nächsten Jahren immer noch am Stand der Technik
  sein.
\item
  Natives Android hat mit großem Abstand die umfassendste Dokumentation.
\item
  An der Schule wird Java unterrichtet. Das macht somit eventuelle
  Modifikationen nach Projektabschluss durch andere Schüler viel
  einfacher möglich.
\item
  Dadurch, dass Kotlin erst seit 2019 \cite{kotlin-preference} offiziell
  die von Google bevorzugte Sprache ist, sind die meisten Tutorials
  immer noch in Java.
\item
  Sehr viele Unternehmen haben viele aktive Java-Entwickler. Dadurch
  wird die App attraktiver, da die Unternehmensmitarbeiter (von
  \zB allegro) keine neue Sprache lernen müssen, um Anpassungen
  durchzuführen.
\item
  Das Projektteam hat im Rahmen eines Praktikums bereits Erfahrungen mit
  nativem Java gesammelt.
\end{itemize}

Aus den Projektzielen hat sich in Absprache mit den Betreuern ergeben,
dass die App nicht auf jedem ``Steinzeitgerät'' zu funktionieren hat.
Das minimale API-Level der App ist daher 21 -- auch bekannt als Android
5.0 ``Lollipop''.

\hypertarget{einfuxfchrung-in-natives-java}{%
\section{Einführung in natives
Java}\label{einfuxfchrung-in-natives-java}}

Um eine Basis für die folgenden Kapitel zu schaffen, werden hier die
Basics der Android-Entwicklung mit nativem Java näher beschrieben.

\hypertarget{grundsuxe4tzliches}{%
\subsection{Grundsätzliches}\label{grundsuxe4tzliches}}

Das Layout einer App wird in XML Dateien gespeichert, während der
Programmcode in der Programmiersprache Java erstellt wird. Damit ist die
Entwicklung einer Android-App objektorientiert.

\hypertarget{single-activity-app}{%
\subsection{Single-Activity-App}\label{single-activity-app}}

Als Einstiegspunkt in eine App dient eine sogenannte \texttt{Activity}.
Eine Activity ist eine normale Java-Klasse, der durch Vererbung
UI-Funktionen verliehen werden.

Bis vor kurzem war es üblich, dass eine App mehrere Activities hat. Das
wird bei den Benutzern dadurch bemerkbar, dass die App \zB bei einem
Tastendruck ein weiteres Fenster öffnet, das das bisherige überdeckt.
Das neue Fenster ist eine eigene Activity. Google hat sich nun offiziell
für sogenannte Single-Activities ausgesprochen \cite{single-activity}.
Das heißt, dass es nur eine Activity und mehrere \texttt{Fragments}
gibt. Ein Fragment ist eine Teilmenge des UIs \bzw einer Activity.
Anstatt jetzt beim Tastendruck eine neue Activity zu starten, wird
einfach das aktuelle Fragment ausgetauscht. Dadurch, dass keine neuen
Fenster geöffnet werden, ist die User Experience (UX) um ein Vielfaches
besser -- die Performanz leidet nur minimal darunter. Die vorliegende
App ist aus diesen Gründen ebenfalls eine Single-Activity-App.

\chapter{Die Inventurlogik auf der App}
\label{inventurlogik_auf_der_app}

Die genaue Bedienung der App ist dem App-Handbuch zu entnehmen. Dieses
Kapitel befasst sich mit der Logik hinter einer Inventur.

\hypertarget{allgemeiner-ablauf-einer-inventur}{%
\section{Allgemeiner Ablauf einer
Inventur}\label{allgemeiner-ablauf-einer-inventur}}

Eine Inventur läuft immer wie folgt ab:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Der Benutzer wählt die Inventur aus, an der er arbeiten will.
\item
  Der Benutzer wählt die Datenbanksicht aus. Dieser Schritt ist
  erforderlich, da die App auch mit der Ralph-Datenbanksicht kompatibel
  ist. An der Schule ist die HTL-Datenbanksicht auszuwählen.
\item
  Der Benutzer begibt sich zu einem Raum und wählt ihn auf der App aus.
\item
  Der Benutzer erhält die Gegenstandsliste für diesen Raum. Diese
  Gegenstandsliste gilt es abzuarbeiten.
\item
  Der Benutzer scannt die Barcodes der Gegenstände und arbeitet sie
  dadurch ab. Nicht aufgelistete Gegenstände werden automatisch ergänzt.
\item
  Der Benutzer kann auf Gegenstandsbasis Änderungen an den Feldern eines
  Gegenstandes vornehmen.
\item
  Wenn der Benutzer der Meinung ist, alle Gegenstände in diesem Raum
  erfasst zu haben, sendet er seine Validierungen an den Server.
\item
  Damit ist der ausgewählte Raum abgeschlossen und der Benutzer kann
  sich dem nächsten Raum annehmen.
\end{enumerate}

Alle Informationen, die die App bezieht, stammen vom Server.

\hypertarget{die-modelle}{%
\section{Die Modelle}\label{die-modelle}}

Um die Antworten des Servers abzubilden, wurden mehrere Modell-Klassen
erstellt. Folgende Modell-Klassen wurden angelegt:

\begin{itemize}
\tightlist
\item
  \texttt{Stocktaking}: Stellt eine Inventur dar.
\item
  \texttt{SerializerEntry}: Stellt eine Datenbanksicht dar.
\item
  \texttt{Room}: Stellt einen Raum dar.
\item
  \texttt{MergedItem}: Stellt einen Gegenstand dar.
\item
  \texttt{MergedItemField}: Stellt ein dynamisches Feld dar.
\item
  \texttt{Attachment}: Stellt einen Anhang dar.
\end{itemize}

\hypertarget{designgrundsuxe4tze}{%
\subsection{Designgrundsätze}\label{designgrundsuxe4tze}}

Eine Modell-Klasse verwaltet etwaige Statusinformationen immer selbst.
So weiß beispielsweise nur ein Gegenstand selbst, dass er ursprünglich
aus einem anderen Raum stammt. Dies verbessert die Lesbarkeit und
Wartbarkeit des Codes massiv, da diese Informationen abstrahiert sind
und nicht mehrmals an verschiendenen Stellen im Quellcode schlummern.

\hypertarget{die-fragments}{%
\section{Die Fragments}\label{die-fragments}}

Eine Inventur wird auf der App durch folgendene Fragments abgewickelt,
die gleichzeitig als Phasen verstanden werden können:

\begin{itemize}
\tightlist
\item
  \texttt{StocktakingFragment}
\item
  \texttt{RoomsFragment}
\item
  \texttt{ViewPagerFragment}

  \begin{itemize}
  \tightlist
  \item
    \texttt{MergedItemsFragment}
  \item
    \texttt{ValidatedMergedItemsFragment}
  \end{itemize}
\item
  \texttt{DetailedItemFragment}
\item
  \texttt{AttachmentsFragment}
\end{itemize}

\hypertarget{stocktakingfragment}{%
\paragraph{StocktakingFragment}\label{stocktakingfragment}}

ist das Fragment, in dem der Benutzer die aktuelle Inventur auswählt.
Die Inventur kann nur vom Administrator am Server angelegt werden.

Außerdem wählt der Benutzer hier die Datenbanksicht (``den Serializer'')
aus. Die App kommuniziert ausschließlich mittels REST API mit dem
Server. Diese Schnittstelle kann verschiedene Quellen haben. Die Quellen
sind abhängig von der ausgewählten Datenbanksicht.

Durch das Bestätigen eines langegezogenen blauen Buttons gelangt man
immer zur nächsten Inventurphase. In diesem Fall gelangt man zum
\texttt{RoomsFragment}.

\hypertarget{roomsfragment}{%
\paragraph{RoomsFragment}\label{roomsfragment}}

ist das Fragment, in dem der Benutzer den aktuellen Raum über eine
DropDown auswählt. Anstatt die DropDown zu verwenden, kann er alternativ
auch die Suchleiste verwenden. Als zusätzliche Alternative hat der
Benutzer die Möglichkeit den Barcode eines Raumes zu scannen. Nach der
Auswahl eines Raumes gelangt man zum \texttt{ViewPagerFragment}.

\hypertarget{viewpagerfragment}{%
\paragraph{ViewPagerFragment}\label{viewpagerfragment}}

ist das Fragment, das als Wrapper für das \texttt{MergedItemsFragment}
und das \texttt{ValidatedMergedItemsFragment} dient. Die einzige Aufgabe
dieses Fragments ist es, die zwei vorher genannten Fragments als Tabs
anzuzeigen. Dies wurde mit der neuen \texttt{ViewPager2}-Library
realisiert \cite{viewpager2}.

\hypertarget{mergeditemsfragment-validatedmergeditemsfragment}{%
\paragraph{MergedItemsFragment \&
ValidatedMergedItemsFragment}\label{mergeditemsfragment-validatedmergeditemsfragment}}

sind die Fragments, die die Gegenstandsliste eines Raumes verwalten und
sie dem Benutzer anzeigen. Das \texttt{MergedItemsFragment} zeigt dem
Benutzer die noch zu validierenden Gegenstände an. Das
\texttt{ValidatedMergedItemsFragment} erfüllt nur den Zweck, dem
Benutzer bereits validierte Gegenstände anzuzeigen und ihm die
Möglichkeit zu geben, validierte Gegenstände zurück zu den
nicht-validierten Gegenständen in \texttt{MergedItemsFragment} zu
verschieben. Daher trägt der Tab für das \texttt{MergedItemsFragment}
die Beschriftung ``TODO'', währenddessen der Tab für das
\texttt{ValidatedMergedItemsFragment} die Beschriftung ``DONE'' trägt.

Beide Fragments verwenden eine \texttt{RecyclerView}, um dem Benutzer
die Gegenstände anzuzeigen \cite{recyclerview}. Eine RecyclerView
generiert pro Eintrag ein Layout, hält aber nur die aktuell angezeigten
Einträge \inkl. Layout im RAM.

Die Gegenstände werden einzeln validiert. Durch das Scannen des Barcodes
eines Gegenstands (beziehungsweise durch das Klicken auf seine
GUI-Repräsentation) gelangt der Benutzer zum
\texttt{DetailedItemFragment}.

\hypertarget{detaileditemfragment}{%
\paragraph{DetailedItemFragment}\label{detaileditemfragment}}

ist das Fragment, das zur Validierung eines einzelnen Gegenstands dient.
Der Benutzer hat hier die Möglichkeit, etwaige Eigenschaften des
Gegenstandes (beispielsweise den Anzeigenamen) zu ändern. Ein Formular,
dass die Felder eines Gegenstandes beinhaltet, wird einmal angefordert
und anschließend für die gesamte Lebensdauer der App gespeichert. Anhand
dieses Formulars wird dann eine GUI-Repräsentation dynamisch erstellt.

Das Formular kann \texttt{ExtraFields} beinhalten. Das sind Felder, die
als nicht essentiel angesehen werden und infolgedessen standardmäßig
eingeklappt sind. Dazu gehören auch benutzerdefinierte Felder --
sognannte \texttt{CustomFields}. \texttt{ExtraFields} weisen ansonsten
dasselbe Verhalten wie herkömmliche Felder auf.

Folgende GUI-Komponenten wurden statisch implementiert, da sie Felder
repräsentieren, die unabhängig von der ausgewählten Datenbanksicht immer
vorhanden sind und daher nicht dynamisch sind:

\begin{itemize}
\tightlist
\item
  Ein read-only Textfeld für die Gegendstandsbeschreibung
\item
  Ein read-only Textfeld für den Barcode
\item
  Eine Checkbox ``Erst später entscheiden''
  (\siehe{das-stocktakingitem-modell})
\item
  Eine DropDown für Subrooms (\siehe{subrooms})
\end{itemize}

Man braucht für die gesamte Validierung eines Raumes -- insofern keine
Sonderfälle auftreten -- keine Verbindung zum Server. Der Benutzer kann
die Gegenstandsliste an einer Lokalität mit einer guten Verbindung
anfordern, den Raum mit schlechter Verbindung betreten und alle
Gegenstände validieren. Anschließend kann er den Raum verlassen und
seine Validierungen an den Server senden. Damit wird der Bedarf an
Netzwerkanfragen in Räumen mit schlechter Netzwerkverbindung minimiert.

Der Benutzer kann zusätzlich zur Validierung auch Anhänge für einen
Gegenstand definieren, dazu landet er beim \texttt{AttachmentsFragment}.

\hypertarget{attachmentsfragment}{%
\paragraph{AttachmentsFragment}\label{attachmentsfragment}}

ist das Fragment, das die Anhänge eines Gegenstandes verwaltet. Der
Benutzer sieht hier die bereits vorhandenen Anhänge mit Beschriftungen
und kann weitere Anhänge hinzufügen. Bilder werden direkt angezeigt.
Andere Dateien werden hingegen als Hyperlink dargestellt. Der Benutzer
kann diese per Browser runterladen. Zum Hochladen eigener Anhänge greift
die App auf den Standard-Dateibrowser des Systems zurück.

Das Outsourcen auf Webbrowser und Dateibrowser bietet den massiven
Vorteil, dass man sich die Entwicklung eigener Download-Manager
\bzw File-Manager erspart und auf Apps setzen kann, die von namenhaften
Herstellern entwickelt werden. Fast jedes System hat bereits beide
Komponenten vorinstalliert, daher treten bezüglich der Verfügbarkeit
keine Probleme auf.

Beim dem Hochladen von Bildern komprimiert die App jene zuvor. Zur
Kompression wird das \texttt{WEBP}-Format verwendet, das dem
mittlerweile veralteten \texttt{JPG}-Standard überlegen ist \cite{webp}.
Die Qualität des Bildes ist einstellbar:

\begin{itemize}
\tightlist
\item
  100 \% (keine Kompression)
\item
  95 \%
\item
  85 \%
\item
  75 \%
\end{itemize}

Der Server speichert den gesendeten Anhang nur einmal (Dateien werden
anhand von Hashes unterschieden). Wenn ein Benutzer allen PCs in einem
EDV-Saal dasselbe Bild zuweist, wird es nur einmal am Server hinterlegt.
Die Anzahl der Anhänge ist nicht limitiert.

\hypertarget{validierungslogik}{%
\section{Validierungslogik}\label{validierungslogik}}

\texttt{MergedItemsFragment} \& \texttt{DetailedItemFragment} sind die
Fragments, die den Großteil einer Inventur ausmachen. Der Benutzer
scannt alle SAP-Barcodes, die sich in einem Raum befinden. Im Idealfall
entspricht diese Menge exakt der Menge der Gegenstände, die dem Benutzer
im \texttt{MergedItemsFragment} angezeigt wird. Im Normalfall wird dies
durch etwaige Sonderfälle jedoch nicht gegeben sein. Nach dem Scannen
eines Gegenstandes werden die Felder des Gegenstandes dem Benutzer im
\texttt{DetailedItemFragment} angezeigt. In diesem Fragment hat der
Benutzer zwei Buttons, mit denen er den Gegenstand validieren kann:

\begin{itemize}
\tightlist
\item
  \textbf{Grüner Button}: Mit diesem Button wird signalisiert, dass sich
  der Gegenstand im Raum befindet und der Gegenstand wird mitsamt
  etwaigen Änderungen an seinen Attributen/Feldern übernommen. Dazu wird
  ein \texttt{ValidationEntry} erstellt. Alternativ kann der Benutzer
  das Klicken dieses Buttons mit dem Schütteln des Gerätes ersetzen. Die
  Schüttel-Sensibilität ist über die Einstellungen konfigurierbar (und
  auch deaktivierbar).
\item
  \textbf{Roter Button}: Mit diesem Button wird signalisiert, dass sich
  der Gegenstand nicht im Raum befindet. Dieser Button wird im
  Normalfall nie betätigt werden, da ein Gegenstand, der sich nicht in
  diesem Raum befindet, nicht gescannt werden kann und daher dieses
  Fenster nie geöffnet werden wird. Der Button hat trotzdem einen Sinn,
  da der Benutzer damit die ``TODO''-Liste über das GUI verkleinern
  kann, um sich einen besseren Überblick zu verschaffen.
\end{itemize}

\hypertarget{der-validationentry}{%
\subsection{Der ValidationEntry}\label{der-validationentry}}

Ein \texttt{ValidationEntry} beinhaltet sämtliche Informationen, die der
Server benötigt, um die Datensätze eines Gengenstandes entsprechend
anzupassen, und stellt eine Gegenstandsvalidierung dar. Ein
\texttt{ValidationEntry} beinhaltet immer den Primary Key eines
Gegenstandes und die Felder, die sich geändert haben. Ein
\texttt{ValidationEntry} hat daher eine Liste an Feldern
\texttt{List\textless{}Field\textgreater{}}. Wenn sich der Wert eines
Feldes geändert hat, wird diese Liste um einen Eintrag erweitert.

Da die Felder wie erwähnt dynamisch (und dadurch generisch) sind, wurden
Java Generics eingesetzt \cite{java-generics}, um diese abbilden zu
können. \texttt{Field} ist eine innere Klasse in
\texttt{ValidationEntry}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \DataTypeTok{static} \KeywordTok{class} \BuiltInTok{Field}\NormalTok{<T> \{}
    \KeywordTok{private} \BuiltInTok{String}\NormalTok{ fieldName;}
    \KeywordTok{private}\NormalTok{ T fieldValue;}
\NormalTok{    ...}
\end{Highlighting}
\end{Shaded}

Ein Feld besteht also immer aus einem Feldnamen und einem generischen
Feldwert.

\hypertarget{sendeformat}{%
\subsubsection{Sendeformat}\label{sendeformat}}

Das \texttt{MergedItemsFragment} (\bzw das \texttt{MergedItemsViewModel}
\siehe{die_app_architektur}) verfügt über eine \texttt{HashMap}
(\texttt{Map\textless{}MergedItem,\ List\textless{}ValidationEntry\textgreater{}\textgreater{}}),
die alle \texttt{ValidationEntries} beinhaltet. Einem Gegenstand ist
eine Liste an \texttt{ValidationEntries} zugeordnet, da Subitems eigene
\texttt{ValiditionEntries} bekommen können
(\siehe{sonderfuxe4lle-auf-der-app}).

Wenn ein Raum abgeschlossen ist, werden alle \texttt{ValidationEntries}
in einer Liste vereint und anschließend in eine JSON-Darstellung
transformiert. Dieses JSON wird dem Server gesandt und damit ist der
aktuelle Raum abgeschlossen. Der Benutzer kann sich nun den restlichen
Räumen annehmen. Die genaue Kommunikationsarchitektur wird im Kapitel
\protect\hyperlink{das-repository-im-detaila}{``Das Repository im
Detail''} beschrieben (\siehe{das-repository-im-detail}).

Der Server erstellt auf Basis der gesendeten \texttt{ValidationEntries}
Änderungsvorschläge -- sogenannte \texttt{Change\ Proposals}
(\siehe{uxe4nderungsvorschluxe4ge}). Das \texttt{POST}-Format wird im
Kapitel \protect\hyperlink{json-schema}{``JSON-Schema''} beschrieben
(\siehe{json-schema}).

\hypertarget{quickscan}{%
\subsection{QuickScan}\label{quickscan}}

Der häufigste Fall einer Inventur wird jener sein, dass ein Gegenstand
im richtigen Raum ist und der Benutzer ohne weiteren Input auf den
grünen Button drückt. Da dies einen unnötigen Overhead darstellt, wurde
die App um den \texttt{QuickScan}-Modus erweitert. Hierbei wird sofort
nach dem Scannen ein \texttt{ValidationEntry} erstellt, ohne dass zuvor
das \texttt{DetailedItemFragment} geöffnet wird. Dieser Modus ist durch
einen Button im \texttt{MergedItemsFragment} aktivierbar/deaktivierbar.

Falls ein Sonderfall auftreten sollte, vibriert das Gerät zweimal und
öffnet doch das \texttt{DetailedItemFragment}. Damit wird gewährleistet,
dass der Benutzer nicht irrtümlich mit dem Scannen weitermacht. Er muss
diesen Sonderfall händisch validieren. Haptisches Feedback ist für
Sonderfälle reserviert.

\hypertarget{sonderfuxe4lle-auf-der-app}{%
\subsection{Sonderfälle auf der App}\label{sonderfuxe4lle-auf-der-app}}

Ein zentrales Thema der vorliegenden Diplomarbeit ist die Behandlung der
Sonderfälle.

\hypertarget{subitems}{%
\subsubsection{Subitems}\label{subitems}}

Wenn sich mehrere physische Gegenstände einen Barcode teilen, werden sie
in der primären Liste lediglich durch einen einzelnen Eintrag
abgebildet. Ein Eintrag des Serversystems kann also mehrere Subitems
zusammenfassen.

Der Server inkludiert in seiner Antwort für jeden Gegenstand einen
Zähler, der die nötigen Informationen zur Behandlung dieses Sonderfalles
beinhaltet. Der Zähler wird in weiterer Folge
\texttt{times\_found\_last}-Zähler genannt. Falls ein Gegenstand aus
mehreren Subitems bestehen sollte, ist der
\texttt{times\_found\_last}-Zähler in der Antwort des Servers größer als
1. Dieser Counter wird dem Benutzer in folgender Form angezeigt:
\texttt{{[}Anzahl\ aktuell\ gefunden{]}\ /\ {[}Anzahl\ zuletzt\ gefunden{]}}.

Bei der Validierung eines Subitems wird ein eigener
\texttt{ValidationEntry} erstellt und die Anzahl der aktuellen Funde
erhöht. \texttt{Change\ Proposals} (\siehe{uxe4nderungsvorschluxe4ge}),
die auf Basis dieser \texttt{ValidationEntries} erstellt werden, werden
dem echten ``Parent''-Gegenstand zugeordnet und können wahlweise
angewandt werden.

Falls ein Gegenstand mehrmals gescannt wird, wird -- nach Bestätigung
durch den Benutzer -- die Anzahl der aktuellen Funde erhöht und wiederum
einen \texttt{ValidationEntry} erstellt, selbst wenn es sich bei dem
Gegenstand aktuell nicht um ein Subitem handelt.

\hypertarget{subrooms}{%
\subsubsection{Subrooms}\label{subrooms}}

Subrooms sind logische Räume in einem Raum (\zB steht ein PC in einem
Kasten, der wiederum in einem Raum steht). Subrooms werden dem Benutzer
im \texttt{MergedItemsFragment} als einklappbare Zwischenebenen, denen
Gegenstände zugeordnet sind, angezeigt. Die Subroom-Zugehörigkeit kann
auf Gegenstandsbasis über eine DropDown geändert werden. Die
Subroom-Zugehörigkeit wird in einem \texttt{ValidationEntry} immer
gesetzt, auch wenn sie sich nicht geändert hat.

Die Gegenstandsliste des \texttt{MergedItemsFragment} beinhaltet in
Wahrheit auch die Subrooms. Dies ist notwendig, da die
\texttt{RecyclerView}, die dazu genutzt wird dem Benutzer die
Gegenstände anzuzeigen, keine Möglichkeit bietet, eine Hierarchie
\bzw Zwischenebenen darzustellen. Daher implementieren das
\texttt{Room}-Modell und das \texttt{MergedItem}-Modell das Interface
\texttt{RecyclerViewItem} und die RecyclerView erhält eine Liste an
\texttt{RecyclerViewItems} - dies ist ein typisch polymorpher Ansatz.
Abhängig vom Typen des aktuellen Listenelements baut die RecyclerView
entweder ein Gegenstandslayout oder ein Raumlayout auf. Die Anzahl der
Subrooms ist weder in der Tiefe noch in der Breite limitiert.

\hypertarget{unbekannte-gegenstuxe4nde}{%
\subsubsection{Unbekannte Gegenstände}\label{unbekannte-gegenstuxe4nde}}

Falls ein Gegenstand, der sich nicht in der aktuellen Gegenstandsliste
befindet, gescannt wird, muss der Server dazu befragt werden. Es gibt
zwei mögliche Antwortszenarien. Die \texttt{ValidationEntries} für diese
Sonderfälle unterscheiden sich nicht von den bisherigen.

\hypertarget{neuer-gegenstand}{%
\subparagraph{Neuer Gegenstand}\label{neuer-gegenstand}}

Der Gegenstand befindet sich überhaupt nicht in der Datenbank. Im
``DONE''-Tab haben solche Gegenstände eine blaue Hervorhebung.

\hypertarget{gegenstand-aus-anderem-raum}{%
\subparagraph{Gegenstand aus anderem
Raum}\label{gegenstand-aus-anderem-raum}}

Der Gegenstand befindet in der Datenbank und stammt ursprünglich aus
einem anderen Raum. Im ``DONE''-Tab haben solche Gegenstände eine orange
Hervorhebung.

\chapter{Die App-Architektur}
\label{die_app_architektur}

Die App muss ein verlässliches und vorhersehbares Verhalten aufweisen.
Die vom Benutzer erstellten Validierungen dürfen beispielsweise nicht
einfach verschwinden. Um das zu gewährleisten, ist eine durchdachte
App-Architektur vonnöten. Da die App-Architektur ein sehr zeitintensiver
und zentraler Aspekt der vorliegenden Diplomarbeit ist, der als
Fundament für die eigentlichen Ziele dient, folgt nun eine ausführliche
Erläuterung.

\hypertarget{separation-of-concerns}{%
\section{Separation of Concerns}\label{separation-of-concerns}}

In Android ist es eine äußerst schlechte Idee, sämtliche Logik in einer
Activity oder einem Fragment zu implementieren. Das softwaretechnische
Prinzip \texttt{Separation\ of\ Concerns\ (SoC)} hat unter Android einen
besonderen Stellenwert. Dieses Prinzip beschreibt im Wesentlichen, dass
eine Klasse nur einer Aufgabe dienen sollte. Falls eine Klasse mehrere
Aufgaben erfüllt, so muss diese auf mehrere logische Komponenten
aufgeteilt werden. Beispiel: Eine Activity \bzw ein Fragment hat immer
die Verantwortung, die Kommunikation zwischen UI und Benutzer
abzuwickeln. Bad Practice wäre es, wenn eine Activity ebenfalls dafür
verantwortlich ist, Daten von einem Server abzurufen.

Das Prinzip verfolgt das Ziel, die
\texttt{God\ Activity\ Architecture\ (GAA)} möglichst zu vermeiden
\cite{god-activities}. Eine God-Activity ist unter Android eine
Activity, die die komplette Business-Logic beinhaltet und \texttt{SoC}
in jeglicher Hinsicht widerspricht. God-Activities gilt es dringlichst
zu vermeiden, da sie folgende Nachteile mit sich bringen:

\begin{itemize}
\tightlist
\item
  Refactoring wird kompliziert
\item
  Wartung und Dokumentation werden äußerst schwierig
\item
  Automatisiertes Testing (\zB Unit-Testing) wird nahezu unmöglich
  gemacht
\item
  Größere Bug-Anfälligkeit
\item
  Im Bezug auf Android gibt es oftmals massive Probleme mit der
  Konsistenz einer Activity -- da eine Activity und ihre Daten schnell
  vernichtet werden können (\zB wenn der Benutzer sein Gerät rotiert und
  das Gerät den Bildschirmmodus wechselt,
  \siehe{das-fragment-und-das-viewmodel-im-detail})
\end{itemize}

God-Activities sind ein typisches Beispiel für Spaghetticode.

Als Reaktion auf eine Vielzahl von Apps, die Probleme mit God-Activites
aufwiesen, hat Google Libraries veröffentlicht, die klar auf eine
MVVM-Architektur abzielen \cite{mvvm}. Daher fiel die Wahl der
App-Architektur auf MVVM.

\hypertarget{designgrundlagen-von-mvvm}{%
\section{Designgrundlagen von MVVM}\label{designgrundlagen-von-mvvm}}

MVVM steht für Model-View-Viewmodel \cite{mvvm-wiki}. Wie man am Namen
bereits erkennt, gilt es zwischen drei Komponenten/Ebenen zu
unterscheiden \cite{mvvm-article}.

\hypertarget{model}{%
\paragraph{Model}\label{model}}

Model beschreibt die Ebene der Daten und wird daher oftmals auch als
Datenzugriffsschicht bezeichnet. Diese Ebene beinhaltet so viel
Anwendungslogik wie möglich.

\hypertarget{view}{%
\paragraph{View}\label{view}}

View beschreibt die graphische Ebene und umfasst daher das GUI. Diese
Ebene soll so wenig Logik wie möglich beinhalten.

\hypertarget{viewmodel}{%
\paragraph{ViewModel}\label{viewmodel}}

Das ViewModel dient als Bindeglied zwischen dem Model und der View. Die
Logik der View wird in diese Ebene hinaufverschoben.

\hypertarget{mvvm-in-android}{%
\section{MVVM in Android}\label{mvvm-in-android}}

Mit der Einführung der \texttt{Architecture\ Components} hat Google
Android-Entwicklern eine Vielzahl an Libraries zur Verfügung gestellt,
um MVVM leichter in Android implementieren zu können
\cite{mvvm-architecture-components}. Die konkrete Implementierung in
Android ist in Abbildung \abb{fig:mvvm} ersichtlich.

\begin{figure}
\centering
\includegraphics[width=2.60417in,height=\textheight]{mvvm.png}
\caption{MVVM in Android nach Google \cite{mvvm} \cite{mvvm-bild}
\label{fig:mvvm}}
\end{figure}

In dem vorliegenden Fall ist unser \texttt{Fragment} die \texttt{View},
das \texttt{Repository} das \texttt{Model} und das \texttt{ViewModel}
ist in Android namensgleich. MVVM ist streng hierarchisch. Wie in der
Abbildung zu erkennen ist, kommuniziert jede Ebene nur mit der
hierarchisch nächsten Ebene.

\hypertarget{das-repository-im-detail}{%
\subsection{Das Repository im Detail}\label{das-repository-im-detail}}

Wie in der \abb{fig:mvvm} veranschaulicht, ist das Repository alleinig
dafür zuständig, Daten vom Server anzufordern. Beispielsweise wird die
Gegenstandsliste für einen Raum vom Repository angefordert -- und von
keiner anderen Ebene. Die Kommunikation zwischen der App und dem Server
findet ausschließlich im \texttt{JSON}-Format statt. JSON ist ein
text-basiertes und kompaktes Datenaustauschformat
\cite{json-format-doku}.

Das Repository fordert JSON an und instanziiert anschließend anhand der
Serverantwort Objekte der Modell-Klassen (\siehe{die-modelle}). Das
Repository ist die einzige Ebene, die mit den rohen JSON-Antworten des
Servers arbeitet. Die restlichen Ebenen arbeiten mit den abstrahierten
Objekten, also \zB mit \texttt{MergedItems} oder \texttt{Rooms}.

Die Kommunikation zwischen dem Server und der App wird mit zwei
Libraries abgewickelt:

\begin{itemize}
\tightlist
\item
  Volley
\item
  Retrofit
\end{itemize}

\hypertarget{jsonrequest-volley}{%
\subsubsection{JsonRequest (Volley)}\label{jsonrequest-volley}}

Android bietet Entwicklern eine Out-of-the-box Netzwerklibrary namens
\texttt{Volley} an, mithilfe derer man unter anderem JSON-Anfragen
verarbeiten kann \cite{volley}. Da diese für die vorliegenden Zwecke
nicht komplett geeignet war, hat das Diplomarbeitsteam die gegebene
Library durch den Einsatz von Vererbung und einer Wrapper-Klasse
modifiziert. Die Library wurde in folgenden Punkten angepasst:

\begin{itemize}
\tightlist
\item
  Im Falle eines Fehlers wird die Anfrage wiederholt (Ausnahme:
  Zeitüberschreitungsfehler). Die maximale Anzahl an Wiederholungen ist
  limitiert.
\item
  Die maximale Timeout-Dauer wurde erhöht.
\item
  Leere Antworten werden von der App als valide Antwort behandelt und
  können ohne Fehler verarbeitet werden.
\item
  Im Header der Anfrage wird der Content-Type der Anfrage auf JSON
  festgelegt.
\item
  Im Header wird das zur Authentifikation notwendige API-Token
  mitgeschickt. Die Authentifizierung ist über einen Parameter
  deaktivierbar.
\item
  Im Header wird die Systemsprache des Clients als standardisierter
  ISO-639-Code mitgesendet. Der Server passt seine Antwort auf die
  verwendete Sprache an \cite{ISO-639}. Die Bezeichnung der Felder, die
  dem Benutzer auf Gegenstandsbasis angezeigt werden, ist beispielsweise
  abhängig von der Systemsprache.
\item
  Zum Zeitpunkt der Anfrage ist nicht bekannt, ob die Antwort als
  \texttt{JSONArray} (\zB für eine Gegenstandsliste) oder als
  \texttt{JSONObject} (\zB für einen explizit angefragten Gegenstand)
  erfolgen wird. Da das Backend abhängig von der Anfrage sowohl mit
  einem \texttt{JSONArray} als auch einem \texttt{JSONObject} antworten
  kann, ist der Rückgabewert der Netzwerkanfrage immer ein String. Die
  Umwandlung erfolgt erst im Repository. Dies führt zu keinen
  Perfomance-Problemen, da die vorgefertigte Android Library den String
  zwar zu einem früheren Zeitpunkt aber auf dieselbe Weise umwandeln
  würde.
\end{itemize}

Diese Anpassungen wurden aus zwei Gründen vorgenommen:

\begin{itemize}
\tightlist
\item
  Um eine robustere Netzwerklibrary zu erhalten, die es ermöglicht in
  Räumen mit Netzwerkproblemen dennoch eine Inventur durchzuführen.
\item
  Um eine spätere Abstraktion der Netzwerkanfragen durchführen zu können
  (\siehe{konkrete-mvvm-implementierung}).
\end{itemize}

Sämtliche Netzwerkanfragen (die Raumliste, die Gegenstandsliste etc.)
werden mit der modifizierten \texttt{Volley}-Library durchgeführt. Die
einzige Ausnahme sind hierbei die Anhänge (\siehe{retrofit}).

\hypertarget{jsonrequest-beispiel}{%
\subsubsection{JsonRequest -- Beispiel}\label{jsonrequest-beispiel}}

Eine Anfrage wird nie direkt, sondern immer über einen Wrapper
ausgeführt. Der Konstruktor ist wie folgt aufgebaut:

\begin{itemize}
\tightlist
\item
  \texttt{Context\ context}: Ist eine Schnittstelle, die globale
  Information über die App-Umgebung zur Verfügung stellt \cite{context}
  und von Android zur Verfügung gestellt wird. Jede UI-Komponente
  (\zB Textfelder, Buttons, Fragments, etc.) verfügt über einen Context.
  Ein besonderer Context ist der globale Application-Context. Dieser ist
  einzigartig und ist ein \texttt{Singleton}. Ein Singleton bedeutet,
  dass von einer Klasse nur ein (globales) Objekt besteht
  \cite{singleton}.
\item
  \texttt{int\ method}: Ist die HTTP-Methode. Die App verwendet
  \texttt{GET}, \texttt{OPTIONS} und \texttt{POST}.
\item
  \texttt{String\ url}: Ist die URL, die eine JSON-Antwort liefern soll.
\item
  \texttt{@Nullable\ String\ requestBody}: Eventuelle Parameter, die an
  den Server gesendet werden sollen. Dieser Paramter ist für einen
  \texttt{POST}-Request wichtig.
\item
  \texttt{NetworkSuccessHandler\ successHandler}: Funktionales Interface
\item
  \texttt{NetworkErrorHandler\ errorHandler}: Funktionales Interface
\end{itemize}

Ein Request kann wie folgt ausschauen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{RobustJsonRequestExecutioner robustJsonRequestExecutioner =}
 \KeywordTok{new} \FunctionTok{RobustJsonRequestExecutioner}\NormalTok{(context, }\BuiltInTok{Request}\NormalTok{.}\FunctionTok{Method}\NormalTok{.}\FunctionTok{GET}\NormalTok{,}
  \StringTok{"https://www.beispiel.org/"}\NormalTok{, }\KeywordTok{null}\NormalTok{, }
\NormalTok{  payload -> \{}
         \CommentTok{// }\AlertTok{TODO}\CommentTok{: Antwort verarbeiten}
         \CommentTok{// -> Anhand der Antwort Modell-Objekte instanziieren}
\NormalTok{     \},}
\NormalTok{  error -> \{}
         \CommentTok{// }\AlertTok{TODO}\CommentTok{: Fehler verarbeiten}
\NormalTok{     \});}
     
\NormalTok{ robustJsonRequestExecutioner.}\FunctionTok{launchRequest}\NormalTok{();}
\end{Highlighting}
\end{Shaded}

Wie man sehen kann, sind die letzten beiden Parameter funktionale
Interfaces, die dazu dienen, Methoden als Parameter übergeben zu können.
Ein Interface mit einer einzigen abstrakten Methode ist als funktionales
Interface zu bezeichnen \cite{lambda}. Da Android Studio Java 8 Language
Features unterstützt, verwendet die App mehrheitlich Lambda-Ausdrücke
\cite{java8}. Lambda-Ausdrücke sind im Wesentlichen dazu da, funktionale
Interfaces in vereinfachter Schreibweise verwenden zu können. Da es nur
eine einzige abstrakte Methode gibt, kann die Schreibweise simplifiziert
werden, weil klar ist, von welcher Methode die Rede ist. Damit fallen --
wie im obigen Beispiel zu sehen -- redundante Informationen wie
Rückgabetyp und Methodenkörper vollständig weg. Das obige Beispiel würde
ohne Lambda-Ausdrücke wie folgt ausschauen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{RobustJsonRequestExecutioner robustJsonRequestExecutioner = }
 \KeywordTok{new} \FunctionTok{RobustJsonRequestExecutioner}\NormalTok{(context, }\BuiltInTok{Request}\NormalTok{.}\FunctionTok{Method}\NormalTok{.}\FunctionTok{GET}\NormalTok{, }
 \StringTok{"https://www.beispiel.org/"}\NormalTok{, }\KeywordTok{null}\NormalTok{,}
     \KeywordTok{new} \FunctionTok{NetworkSuccessHandler}\NormalTok{() \{}
         \AttributeTok{@Override}
         \KeywordTok{public} \DataTypeTok{void} \FunctionTok{handleSuccess}\NormalTok{(}\BuiltInTok{String}\NormalTok{ payload) \{}
             \CommentTok{// }\AlertTok{TODO}\CommentTok{: Antwort verarbeiten}
             \CommentTok{// -> Anhand der Antwort Modell-Objekte instanziieren}
\NormalTok{         \}}
\NormalTok{     \},}
     \KeywordTok{new} \FunctionTok{NetworkErrorHandler}\NormalTok{() \{}
         \AttributeTok{@Override}
         \KeywordTok{public} \DataTypeTok{void} \FunctionTok{handleError}\NormalTok{(}\BuiltInTok{Exception}\NormalTok{ error) \{}
             \CommentTok{// }\AlertTok{TODO}\CommentTok{: Fehler verarbeiten}
\NormalTok{         \}}
\NormalTok{     \});}

\NormalTok{robustJsonRequestExecutioner.}\FunctionTok{launchRequest}\NormalTok{();}
\end{Highlighting}
\end{Shaded}

Lambdas sind eine Option, um \texttt{Callbacks} in Java zu
implementieren. Ein Callback (``Rückruffunktion'') ist eine Methode, die
einer anderen Methode als Parameter übergeben werden kann. Die soeben
erwähnten funktionalen Interfaces sind typische Callbacks
\cite{Callbacks}. Es gibt zwei Arten von Callbacks:

\begin{itemize}
\tightlist
\item
  Synchrone Callbacks: Die Ausführung der übergebenen Methode erfolgt
  sofort.
\item
  Asynchrone Callbacks: Die Ausführung der übergebenen Methode erfolgt
  zu einem späteren Zeitpunkt.
\end{itemize}

In diesem Fall wird die Methode \texttt{handleSuccess} aufgerufen,
sobald der Client die Antwort erhalten hat. Damit handelt es sich um ein
asynchrones Callback. Callbacks werden in der App sehr häufig
eingesetzt.

\hypertarget{retrofit}{%
\subsubsection{Retrofit}\label{retrofit}}

\texttt{Retrofit} ist eine weitere Netzwerk-Library (\bzw Libraries),
die das Projektteam eingesetzt hat. Retrofit wurde nur zum Senden von
Dateien eingesetzt, weil dies mit Volley nur erschwert möglich ist. Mit
dieser Library wurde die Anhang-Funktion realisiert.

Das Projektteam hat bei dem einzigen die bereits bekannte Callback-Logik
verwendet:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Call<}\BuiltInTok{String}\NormalTok{> call = }\FunctionTok{prepareCall}\NormalTok{(args);}
\NormalTok{call.}\FunctionTok{enqueue}\NormalTok{(}\KeywordTok{new} \BuiltInTok{Callback}\NormalTok{<}\BuiltInTok{String}\NormalTok{>() \{}
    \AttributeTok{@Override}
    \KeywordTok{public} \DataTypeTok{void} \FunctionTok{onResponse}\NormalTok{(Call<}\BuiltInTok{String}\NormalTok{> call, }\BuiltInTok{Response}\NormalTok{<}\BuiltInTok{String}\NormalTok{> response) \{}
        \CommentTok{// }\AlertTok{TODO}\CommentTok{: Antwort verarbeiten}
        \CommentTok{// -> Anhand der Antwort Modell-Objekte instanziieren}
\NormalTok{    \}}
    \AttributeTok{@Override}
    \KeywordTok{public} \DataTypeTok{void} \FunctionTok{onFailure}\NormalTok{(Call<}\BuiltInTok{String}\NormalTok{> call, }\BuiltInTok{Throwable}\NormalTok{ t) \{}
        \CommentTok{// }\AlertTok{TODO}\CommentTok{: Fehler verarbeiten}
\NormalTok{    \}}
\NormalTok{\});}
\end{Highlighting}
\end{Shaded}

In Retrofit werden API-Endpunkte über Interfaces definiert:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{interface}\NormalTok{ AttachmentAPI \{}
    \AttributeTok{@Multipart}
    \AttributeTok{@POST}\NormalTok{(SerializerEntry.}\FunctionTok{attachmentUrl}\NormalTok{)}
\NormalTok{    Call<}\BuiltInTok{String}\NormalTok{> }\FunctionTok{addFile}\NormalTok{(}\AttributeTok{@Header}\NormalTok{(}\StringTok{"authorization"}\NormalTok{) }\BuiltInTok{String}\NormalTok{ auth,}
                         \AttributeTok{@Part}\NormalTok{ MultipartBody.}\FunctionTok{Part}\NormalTok{ file,}
                         \AttributeTok{@Part}\NormalTok{(}\StringTok{"description"}\NormalTok{) }\BuiltInTok{String}\NormalTok{ description);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Dies führt zu einem besseren Überblick als bei Volley, da man pro
API-Endpunkt des Backends ein Interface hat. Damit ist sofort
ersichtlich, mit welchen Backend-Endpunkten ein Repository kommuniziert.

\hypertarget{das-fragment-und-das-viewmodel-im-detail}{%
\subsection{Das Fragment und das ViewModel im
Detail}\label{das-fragment-und-das-viewmodel-im-detail}}

Ein Fragment durchlebt im Laufe seines Daseins eine Vielzahl an
Zuständen/Phasen -- man spricht von einem \texttt{Lifecycle}. Wenn der
Benutzer zum Beispiel sein Gerät rotiert, führt dies dazu, dass das
Fragment \emph{zerstört} wird und das Fragment durch erneutes Durchleben
alter Zustände wiederaufgebaut wird -- dies führt zu einer Zerstörung
des aktuellen UIs des Fragments sowie sämtlicher Referenzen, die das
Fragment besitzt. Fast alle GUI-Komponenten (Fragments, Textfelder etc.)
sind in Android an einen Lifecycle gebunden.

Eine Gerätrotierung gehört zur Kategorie der
\texttt{Configuration\ Changes} \cite{viewmodel}. Der Grund hierfür
liegt darin, dass Android das aktuelle Layout ändert, da beispielsweise
andere Layouts (XML-Files) für den Landscape-Modus zur Verfügung stehen
\cite{configuration-changes}. In der Literatur wird der Begriff
\emph{zerstören} verwendet, da dabei das Callback \texttt{onDestroy} in
einer Activity aufgerufen wird.

Folgende Probleme, die eine Inventur massiv erschweren würden, könnten
durch Lifecycle-Probleme auftreten:

\begin{itemize}
\tightlist
\item
  Die App stürzt ab, wenn eine Methode ausgeführt wird, die eine
  Referenz auf ein zerstörtes Objekt hat.
\item
  \texttt{Memory\ Leaks} entstehen, da Referenzen auf zerstörte Objekte
  vom Gargabe Collector nicht freigegeben werden können. In Android wird
  die Minimierung des Speicherbedarfs der App einzig und allein vom
  Garbage Collector übernommen. Falls dieser Objekte nicht freigeben
  kann, führt dies dazu, dass die App immer mehr und mehr
  Arbeitsspeicher benötigt. Je nach Größe des Memory Leaks kann dies zu
  kleineren Verzögerungen bis zu einem Absturz der App führen.
\item
  Nach einem \texttt{Configuration\ Change} gehen die aktuellen Daten
  verloren und der Benutzer muss das Problem selbst lösen.
\item
  Wenn die aktuellen Daten verloren gehen, verhält sich eine App oftmals
  unvorhersehbar.
\end{itemize}

\hypertarget{viewmodel-als-luxf6sung}{%
\subsubsection{ViewModel als Lösung}\label{viewmodel-als-luxf6sung}}

\begin{figure}
\centering
\includegraphics{viewmodel-lifecycle.png}
\caption{Zustände einer Activity im Vergleich zu den Zuständen eines
ViewModels, Fragments haben einen ähnlichen Lifecycle
\cite{fragment-lifecycle} \cite{viewmodel} \cite{life-bild}
\label{fig:vmlife}}
\end{figure}

Bei genauerer Betrachtung der \abb{fig:vmlife} wird ersichtlich, welche
Phasen eine Activity bei einer Gerätrotierung durchlebt:

\begin{itemize}
\tightlist
\item
  Activity wird zerstört:

  \begin{itemize}
  \tightlist
  \item
    \texttt{onPause}
  \item
    \texttt{onStop}
  \item
    \texttt{onDestroy}
  \end{itemize}
\item
  Activity wird wieder aufgebaut:

  \begin{itemize}
  \tightlist
  \item
    \texttt{onCreate}
  \item
    \texttt{onStart}
  \item
    \texttt{onResume}
  \end{itemize}
\end{itemize}

Wie in der \abb{fig:vmlife} zu sehen ist, stellt ein ViewModel eine
Lösung für diese Probleme dar. Ein ViewModel ist von einem
\texttt{Configuration\ Change} nicht betroffen und kann dem UI damit
stets die aktuellen Daten zur Verfügung stellen. Die Daten erhält das
ViewModel vom Repository. Der gegebene Sachverhalt trifft genauso auf
Fragments zu. Diese haben einen leicht veränderten Lifecycle, sind
allerdings genauso von Configuration Changes betroffen wie Activities.
Das ViewModel ermöglicht es dem Benutzer also eine Inventur konsistent
-- ohne unvorhersehbares Lifecycle-Verhalten -- durchzuführen.

\textbf{Anmerkung}: Man kann das Zerstören \& Wiederaufbauen von
Activities/Fragments manuell blockieren. Dies ist jedoch kein Ersatz für
eine wohlüberlegte App-Architektur und führt in den meisten Fällen zu
unerwünschten Nebenwirkungen, da man sich nun auch manuell um das
Wechseln der Konfiguration (Layouts etc.) kümmern muss und dies weitaus
komplizierter ist, als auf ViewModels zu setzen
\cite{lifecycle-blocking}.

Folgende Details sind bei der Verwendung eines ViewModels zu beachten
\cite{viewmodel-antipatterns}:

\begin{itemize}
\tightlist
\item
  Ein ViewModel sollte bei einem \texttt{Configuration\ Change} keine
  neue Netzwerkanfrage starten, da es bereits über die aktuellen Daten
  verfügt. Dies lässt sich mit einer \texttt{If}-Anweisung beheben.
\item
  Referenzen zu Objekten, die an einen Lifecycle gebunden sind, sind ein
  absolutes NO-GO. Objekte mit Lifecycle haben ein klares Schicksal --
  wenn ihr Host vernichtet wird, müssen sie ebenfalls vernichtet werden.
  \textbf{Folgendes Szenario}: Ein ViewModel hat eine
  \texttt{TextView}-Variable (= ein Textfeld). Dreht der Benutzer sein
  Gerät wird das aktuelle Fragment inklusive \texttt{TextView}
  vernichtet. Das ViewModel überlebt den \texttt{Configuration\ Change}
  und hat nun eine Referenz auf eine invalide \texttt{TextView}. Dies
  ist ein \texttt{Memory\ Leak}.
\item
  ViewModel überleben ein Beenden des App-Prozesses nicht. Wenn das BS
  aktuell wenig Ressourcen zur Verfügung hat, kann es sein, dass Apps
  kurzzeitig beendet werden. Falls man diesen Sonderfall behandeln will,
  ist dies mit Extra-Aufwand verbunden \cite{viewmodel-process-death}.
\item
  ViewModels sollen nicht zu ``God-ViewModels'' werden. Das
  \texttt{SoC}-Prinzip ist anzuwenden.
\end{itemize}

Wie gelangen die Daten wie \zB die Raumliste ins UI, wenn das ViewModel
keine Referenzen auf das UI haben darf? Die Antwort lautet
\texttt{LiveData}.

\hypertarget{livedata}{%
\subsubsection{LiveData}\label{livedata}}

\texttt{LiveData} ist eine observierbare Container-Klasse. Observierbar
heißt, dass bei Änderungen des enkapsulierten Objektes ein Callback
aufgerufen wird. \texttt{LiveData} ist (wie ein ViewModel)
\texttt{lifecycle-aware}. Daher wird \texttt{LiveData} immer nur aktive
Komponenten mit Daten versorgen. Eine \texttt{TextView}, die bereits
zerstört wurde, erhält dementsprechend auch keine Updates mehr.

Dieses (angepasste) offizielle Beispiel veranschaulicht die
Funktionsweise sehr gut \cite{livedata}. Im Beispiel soll ein
Benutzername angezeigt werden:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{class}\NormalTok{ NameViewModel }\KeywordTok{extends}\NormalTok{ ViewModel \{}

    \CommentTok{// LiveData-Objekt, das einen String beinhaltet}
    \KeywordTok{private}\NormalTok{ MutableLiveData<}\BuiltInTok{String}\NormalTok{> currentName;}

    \KeywordTok{public}\NormalTok{ LiveData<}\BuiltInTok{String}\NormalTok{> }\FunctionTok{getCurrentName}\NormalTok{() \{}
        \KeywordTok{if}\NormalTok{ (currentName == }\KeywordTok{null}\NormalTok{) \{}
\NormalTok{            currentName = }\KeywordTok{new}\NormalTok{ MutableLiveData<>();}
\NormalTok{        \}}
        \CommentTok{// Benutzernamen bekannt geben}
\NormalTok{        currentName.}\FunctionTok{postValue}\NormalTok{(}\StringTok{"Max Mustermann"}\NormalTok{);}

        \KeywordTok{return}\NormalTok{ currentName;}
\NormalTok{    \}}

    \CommentTok{// Rest des ViewModels...}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Der Unterschied zwischen \texttt{MutableLiveData} und \texttt{LiveData}
besteht darin, dass letzteres nicht veränderbar ist. Mit der
\texttt{postValue}-Methode kann einer MutableLiveData-Instanz, die ja
als Container-Objekt dient, ein neuer Wert zugewiesen werden. Dadurch
werden etwaige Callbacks aufgerufen (siehe nächster Code-Ausschnitt).
Man sollte bei öffentlichen Methoden immer nur \texttt{LiveData} als
Rückgabewert verwenden, damit auf der Ebene der View keine
Modifikationen der Daten des ViewModels vorgenommen werden können. Im
Realfall stammt \texttt{LiveData} ursprünglich aus dem Repository.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{class}\NormalTok{ NameFragment }\KeywordTok{extends}\NormalTok{ Fragment \{}
 \AttributeTok{@Override}
    \KeywordTok{public} \DataTypeTok{void} \FunctionTok{onViewCreated}\NormalTok{(}\AttributeTok{@NonNull} \BuiltInTok{View}\NormalTok{ view, }
    \AttributeTok{@Nullable}\NormalTok{ Bundle savedInstanceState) \{}
\NormalTok{        ...}

        \CommentTok{// Mit dieser Anweisung wird ein ViewModel erstellt}
\NormalTok{        model = }\KeywordTok{new} \FunctionTok{ViewModelProvider}\NormalTok{(}\KeywordTok{this}\NormalTok{).}\FunctionTok{get}\NormalTok{(NameViewModel.}\FunctionTok{class}\NormalTok{);}

\NormalTok{        model.}\FunctionTok{getCurrentName}\NormalTok{().}\FunctionTok{observe}\NormalTok{(}\FunctionTok{getViewLifecycleOwner}\NormalTok{(),}
\NormalTok{         currentName -> \{}
             \CommentTok{// Diese Methode wird bei Änderungen aufgerufen.}
             \CommentTok{// currentName ist ein String.}
             \CommentTok{// nameTextView ist ein TextFeld, }
             \CommentTok{// das den aktuellen Benutzernamen anzeigt.}
             \CommentTok{// Mit .setText(String) kann der angezeigte Text }
             \CommentTok{// geändert werden.}
\NormalTok{             nameTextView.}\FunctionTok{setText}\NormalTok{(currentName);}
\NormalTok{         \});}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Hier kommt wieder die vorher angesprochene Lambda-Syntax zum Einsatz.
Die Methode wird einmal beim erstmaligen Registrieren aufgerufen und
wird danach bei jeder weiteren Änderung aufgerufen. Im Callback arbeitet
man direkt mit dem eigentlichem Datentypen -- in diesem Fall mit einem
String --, da \texttt{LiveData} nur ein Container-Objekt ist. Im
Fragment befindet sich damit relativ wenig Logik. Das Fragment hört nur
auf eventuelle Änderungen und aktualisiert das UI in Abhängigkeit von
den Änderungen. Ein Großteil der Logik (wie \zB Validierungen oder
Gegenstandslisten) befindet sich also im ViewModel.

Das LiveData-Objekt ist an \texttt{getViewLifeycleOwner()} gebunden.
Wenn der \texttt{LifecycleOwner} inaktiv wird, werden keine Änderungen
mehr entsandt. Man könnte auch \texttt{this} als Argument übergeben
(\texttt{this} wäre in diesem Fall das Fragment, das ebenfalls über
einen Lifecycle verfügt). \texttt{getViewLifeycleOwner()} hat jedoch den
Vorteil, dass der Observer automatisch entfernt wird, sobald der
LifecycleOwner zerstört wird.

\hypertarget{angepasste-livedata-klasse}{%
\subsubsection{Angepasste
LiveData-Klasse}\label{angepasste-livedata-klasse}}

Für den vorliegenden Usecase reichen jedoch die Nutzdaten allein nicht.
Es sind weitere Informationen über den Status der Nutzdaten
erforderlich. \textbf{Beispiel:} Wenn eine Anfrage zehn Sekunden
benötigt, um am Client anzukommen, muss dem Benutzer mittels Ladebalken
(= \texttt{ProgressBar}) signalisiert werden, dass er auf das Backend zu
warten hat.

Man könnte jetzt im ViewModel
\texttt{LiveData\textless{}Boolean\textgreater{}\ isFetching} verwenden
und im Fragment dieses LiveData-Objekt observieren. Falls der aktuelle
Wert \texttt{true} ist, wird die ProgressBar angezeigt. Falls der Wert
auf \texttt{false} geändert wird, werden stattdessen die nun zur
Verfügung stehenden Nutzdaten angezeigt.

Bei mehreren Netzwerkanfragen wird dies bald unübersichtlich, da mehrere
LiveData-Objekte vonnöten sind, die aus logischer Perspektive zu einem
bereits bestehenden LiveData-Objekt gehören -- den Nutzdaten. Daher hat
das Diplomarbeitsteam -- wie von Google \cite{google-wrapper} und von
einem StackOverflow-Thread \cite{so-wrapper} empfohlen -- die Nutzdaten
in einer Wrapper-Klasse (\texttt{StatusAwareData}) enkapsuliert:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{class}\NormalTok{ StatusAwareData<T> \{}

    \CommentTok{// Status der Nutzdaten}
    \AttributeTok{@NonNull}
    \KeywordTok{private} \BuiltInTok{State}\NormalTok{ status;}

    \CommentTok{// Nutzdaten}
    \AttributeTok{@Nullable}
    \KeywordTok{private}\NormalTok{ T data;}

    \CommentTok{// Eventueller Fehler}
    \AttributeTok{@Nullable}
    \KeywordTok{private} \BuiltInTok{Throwable}\NormalTok{ error;}

\NormalTok{    ...}

    \AttributeTok{@NonNull}
    \KeywordTok{public} \BuiltInTok{State} \FunctionTok{getStatus}\NormalTok{() \{}
        \KeywordTok{return}\NormalTok{ status;}
\NormalTok{    \}}

    \AttributeTok{@Nullable}
    \KeywordTok{public}\NormalTok{ T }\FunctionTok{getData}\NormalTok{() \{}
        \KeywordTok{return}\NormalTok{ data;}
\NormalTok{    \}}

    \AttributeTok{@Nullable}
    \KeywordTok{public} \BuiltInTok{Throwable} \FunctionTok{getError}\NormalTok{() \{}
        \KeywordTok{return}\NormalTok{ error;}
\NormalTok{    \}}

    \CommentTok{// Enum, das die legalen Status definiert}
    \KeywordTok{public} \KeywordTok{enum} \BuiltInTok{State}\NormalTok{ \{}
\NormalTok{        INITIALIZED,}
\NormalTok{        SUCCESS,}
\NormalTok{        ERROR,}
\NormalTok{        FETCHING}
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Diese Wrapper-Klasse speichert Nutzdaten eines generischen Typen. Der
Status der Daten wird durch ein \texttt{Enum} abgebildet. Folgende
Status können Nutzdaten haben:

\begin{itemize}
\tightlist
\item
  \texttt{INITIALIZED}: Dieser Status bedeutet, dass das Objekt soeben
  erstellt wurde. Wird nur bei der erstmaligen Instanziierung verwendet.
\item
  \texttt{SUCCESS}: Dieser Status bedeutet, dass die Nutzdaten
  \texttt{data} bereit sind.
\item
  \texttt{ERROR}: Dieser Status bedeutet, dass eine Netzwerkanfrage
  fehlgeschlagen ist (Ob am Client oder am Server spielt keine Rolle).
  In diesem Fall ist die \texttt{error}-Variable gesetzt.
\item
  \texttt{FETCHING}: Dieser Status bedeutet, dass auf eine
  Netzwerkanfrage gewartet wird.
\end{itemize}

In Android sollte man Enums vermeiden, da diese um ein Vielfaches mehr
Arbeitsspeicher und persistenten Speicher benötigen als ihre
Alternativen. Als Alternative kann man auf Konstanten zurückgreifen.
Dieser Code-Ausschnitt stellt das einzige Enum des gesamten Projektes
dar \cite{avoid-enums}.

Um diese Wrapper-Klasse elegant benutzen zu können, hat das Projektteam
\texttt{MutableLiveData} durch Vererbung angepasst:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{class}\NormalTok{ StatusAwareLiveData<T> }
    \KeywordTok{extends}\NormalTok{ MutableLiveData<StatusAwareData<T>> \{}

    \KeywordTok{public} \DataTypeTok{void} \FunctionTok{postFetching}\NormalTok{() \{}
        \CommentTok{// Instanziiert StatusAwareData-Objekt mit FECHTING als }
        \CommentTok{// aktuellen Status.}
        \CommentTok{// Setzt das StatusAwareData-Objekt anschließend }
        \CommentTok{// als Wert der LiveData-Instanz.}
        \FunctionTok{postValue}\NormalTok{(}\KeywordTok{new}\NormalTok{ StatusAwareData<T>().}\FunctionTok{fetching}\NormalTok{());}
\NormalTok{    \}}

    \KeywordTok{public} \DataTypeTok{void} \FunctionTok{postError}\NormalTok{(}\BuiltInTok{Exception}\NormalTok{ exception) \{}
        \CommentTok{// Instanziiert StatusAwareData-Objekt mit ERROR als}
        \CommentTok{// aktuellen Status.}
        \CommentTok{// Mit der übergebenenen Exception wird die error-Variable}
        \CommentTok{// initialisiert.}
        \CommentTok{// Setzt das StatusAwareData-Objekt anschließend }
        \CommentTok{// als Wert der LiveData-Instanz.}
        \FunctionTok{postValue}\NormalTok{(}\KeywordTok{new}\NormalTok{ StatusAwareData<T>().}\FunctionTok{error}\NormalTok{(exception));}
\NormalTok{    \}}

    \KeywordTok{public} \DataTypeTok{void} \FunctionTok{postSuccess}\NormalTok{(T data) \{}
        \CommentTok{// Instanziiert StatusAwareData-Objekt mit SUCCESS als}
        \CommentTok{// aktuellen Status.}
        \CommentTok{// Mit dem übergebenenen Objekt wird die data-Variable}
        \CommentTok{// initialisiert.}
        \CommentTok{// Setzt das StatusAwareData-Objekt anschließend }
        \CommentTok{// als Wert der LiveData-Instanz.}
        \FunctionTok{postValue}\NormalTok{(}\KeywordTok{new}\NormalTok{ StatusAwareData<T>().}\FunctionTok{success}\NormalTok{(data));}
\NormalTok{    \}}

\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Damit entfällt der Bedarf, selbst neue StatusAwareData-Objekte zu
instanziieren, da diese bereits über die \texttt{postFetching}-,
\texttt{postError}- und \texttt{postSuccess}-Methoden -- mit korrektem
Status -- instanziiert werden. Infolgedessen ist
\texttt{StatusAwareData} abstrahiert und im ViewModel genügt es, mit den
modifizierten LiveData-Instanzen zu arbeiten. Damit ändert sich das
vorherige \href{livedata}{``Beispiel''} wie folgt:

\begin{Shaded}
\begin{Highlighting}[]

\CommentTok{// Im ViewModel:}

\CommentTok{// StatusAwareLiveData-Objekt, das einen String mit Status beinhaltet}
\KeywordTok{private}\NormalTok{ StatusAwareLiveData<}\BuiltInTok{String}\NormalTok{> currentName;}

\KeywordTok{public}\NormalTok{ LiveData<StatusAwareData<}\BuiltInTok{String}\NormalTok{>> }\FunctionTok{getCurrentName}\NormalTok{() \{}
    \KeywordTok{if}\NormalTok{ (currentName == }\KeywordTok{null}\NormalTok{) \{}
\NormalTok{        currentName = }\KeywordTok{new}\NormalTok{ StatusAwareLiveData<>();}
\NormalTok{    \}}
    \CommentTok{// Benutzernamen bekannt geben, hier wird eine}
    \CommentTok{// erfolgreiche Netzwerkanfrage simuliert.}
\NormalTok{    currentName.}\FunctionTok{postSuccess}\NormalTok{(}\StringTok{"Max Mustermann"}\NormalTok{);}
       
    \KeywordTok{return}\NormalTok{ currentName;}
\NormalTok{\}}


\CommentTok{// Im Fragment:}

\NormalTok{model.}\FunctionTok{getCurrentName}\NormalTok{().}\FunctionTok{observe}\NormalTok{(}\FunctionTok{getViewLifecycleOwner}\NormalTok{(), }
\NormalTok{ statusAwareData -> \{}
      \KeywordTok{switch}\NormalTok{ (statusAwareData.}\FunctionTok{getStatus}\NormalTok{()) \{}
          \KeywordTok{case}\NormalTok{ SUCCESS:}
              \CommentTok{// }\AlertTok{TODO}\CommentTok{: Nutzdaten anzeigen}
\NormalTok{              nameTextView.}\FunctionTok{setText}\NormalTok{(statusAwareData.}\FunctionTok{getData}\NormalTok{());}
              \KeywordTok{break}\NormalTok{;}
          \KeywordTok{case}\NormalTok{ ERROR:}
              \CommentTok{// }\AlertTok{TODO}\CommentTok{: Fehlermeldung anzeigen}
\NormalTok{              ...}
              \KeywordTok{break}\NormalTok{;}
          \KeywordTok{case}\NormalTok{ FETCHING:}
              \CommentTok{// }\AlertTok{TODO}\CommentTok{: Ladebalken anzeigen}
\NormalTok{              ...}
              \KeywordTok{break}\NormalTok{;}
\NormalTok{      \}}
\NormalTok{   \});}
\end{Highlighting}
\end{Shaded}

\hypertarget{konkrete-mvvm-implementierung}{%
\subsection{Konkrete
MVVM-Implementierung}\label{konkrete-mvvm-implementierung}}

Im vorliegenden Anwendungsfall zeigt das Fragment immer mindestens einen
Datensatz an, der für das Fragment (und die anderen Ebenen) namensgebend
ist. Der Room-Screen (also die Anzeige mit einer DropDown zur
Raumauswahl) setzt sich beispielsweise aus folgenden Komponenten
zusammen:

\begin{itemize}
\tightlist
\item
  Der \texttt{RoomsRepository}-Klasse
\item
  Der \texttt{RoomsViewModel}-Klasse
\item
  Der \texttt{RoomsFragment}-Klasse
\item
  Der \texttt{fragment\_rooms.xml}-Datei, die das UI-Layout definiert
\end{itemize}

Das \texttt{RoomsRepository} ist dafür verantwortlich, die Raumliste vom
Backend anzufordern und in Objekte der Modell-Klasse \texttt{Room}
umzuwandeln. Das \texttt{RoomsViewModel} ist dafür verantwortlich, dem
Fragment LiveData-Objekte zur Verfügung zu stellen. Das
\texttt{RoomsFragment} ist dafür verantwortlich, dem Benutzer die Räume
anzuzeigen, indem es \texttt{LiveData} observiert. Alternativ zeigt es
Fehlermeldungen \bzw einen Ladebalken an.

Bei genauerer Betrachtung wird klar, dass fast jeder Screen dieselbe
Aufgabe hat:

\begin{itemize}
\tightlist
\item
  Das Repository fordert Daten vom Backend an und wandelt die
  JSON-Antwort in Modell-Objekte um.
\item
  Das ViewModel abstrahiert Logik und stellt der View \texttt{LiveData}
  zur Verfügung.
\item
  Das Fragment zeigt entweder Nutzdaten, eine Fehlermeldung oder einen
  Ladebalken an.
\end{itemize}

Hier greift das softwaretechnische Prinzip
\texttt{Do\ not\ repeat\ yourself\ (DRY)} \cite{dry}. Anstatt
\texttt{Boilerplate-Code} für jeden einzelnen Screen kopieren zu müssen,
hat das Projektteam diese sich wiederholende Logik abstrahiert.
Boilerplate-Code sind Code-Abschnitte, die sich immer wieder wiederholen
\cite{boiler}. Wiederholende Logik sollte immer in eine Superklasse
abstrahiert werden. Das Projektteam hat demnach drei abstrakte Klassen
definiert, die die Menge an Boilerplate-Code signifikant reduzieren:

\begin{itemize}
\tightlist
\item
  \texttt{NetworkRepository}
\item
  \texttt{NetworkViewModel}
\item
  \texttt{NetworkFragment}
\end{itemize}

Alle Komponenten von inventurrelevanten Screens erben von diesen drei
Klassen. Damit hat das Projektteam folgende Vorteile aggregiert:

\begin{itemize}
\tightlist
\item
  Abstrahierte Fehlerbehandlung
\item
  Abstrahierte Ladeanzeige
\item
  Abstrahierter Netzwerkzugriff
\item
  Abstrahiertes Refreshverhalten (durch nach unten wischen wie \zB bei
  YouTube)
\end{itemize}

Das Refactoring, das dies realisierte, war zwar zeitintensiv, hat sich
jedoch mittlerweile mehr als rentiert. Das Hinzufügen von neuen Screens
benötigt nur mehr einen Bruchteil des ursprünglichen Codes und jeder
neue Screen hat automatisch die aufgezählten Features inkludiert.
Infolgedessen wird das Erweitern der App um neue Features enorm
erleichtert.

\chapter{Das Scannen}
\label{das_scannen}

Das Scannen ist ein vitaler Aspekt der vorliegenden Diplomarbeit.
Gegenstände an der vorliegenden Organisation sind mit Barcodes
ausgestattet. Der Benutzer wird den Großteil seiner Zeit damit
verbringen, die Gegenstandsliste durch das Scannen von Barcodes
abzuarbeiten. Um die Produktivität maximal zu steigern, muss die App in
der Lage sein, diese Barcodes möglichst schnell zu erfassen. Es werden
folgende Scanvarianten angeboten:

\begin{itemize}
\tightlist
\item
  Zebra-Scan
\item
  Kamerascan
\item
  Manuelle Eingabe (für den Fall, dass ein Scan fehlschlägt)
\end{itemize}

\hypertarget{der-zebra-scan}{%
\section{Der Zebra-Scan}\label{der-zebra-scan}}

Der hervorragende Sponsor dieser Diplomarbeit -- Zebra -- hat dem
Diplomarbeitsteam einen \texttt{TC56} (``Touch Computer'') zur Verfügung
gestellt. Dieser verfügt über einige Eigenschaften, die für eine
Inventur vom Vorteil sind \cite{zebra-tc56}:

\begin{itemize}
\tightlist
\item
  Ein in das Smartphone integrierter Barcodescanner reduziert die
  Scanzeiten drastisch.
\item
  Ein Akku mit über 4000 mAh ermöglicht mehrstündige Inventuren.
\item
  Viel Arbeitsspeicher und ein leistungsstarker Prozessor ermöglichen
  ein flüssiges App-Verhalten.
\item
  Dank robuster Bauart hält das Gerät auch physisch anspruchsvollere
  Phasen einer Inventur aus.
\end{itemize}

\hypertarget{zebra-scan-funktionsweise}{%
\subsection{Zebra-Scan:
Funktionsweise}\label{zebra-scan-funktionsweise}}

Die App kommuniziert nicht direkt mit dem Scanner. Auf dem Zebra-Gerät
läuft im Hintergrund immer die DataWedge-Applikation. Dies ist eine App,
die die Behandlung des tatsächlichen Scans abwickelt und das Ergebnis
auf mehrere Arten aussendet \cite{datawedge}. Beispielsweise wird das
Ergebnis an die Tastatur geschickt, aber auch als \texttt{Broadcast} an
das Betriebssystem \cite{broadcast}.

Die App registriert sich beim Betriebssystem und hört auf den Broadcast,
der den Barcode enthält und automatisch von DataWedge entsandt wird.
Broadcasts werden durch eine String-ID unterschieden, die über DataWedge
konfiguriert wird. Derartige Ansätze werden als Publish--subscribe-Model
bezeichnet \textbackslash cite\{publish--subscribe\}.

Dies bietet folgende Vorteile:

\begin{itemize}
\tightlist
\item
  Die Hardware wird komplett abstrahiert. Die vorliegende App ``sieht''
  den Scanner zu keinem Zeitpunkt.
\item
  Durch die Abstrahierung des Scanners wird die eigene Codebasis kleiner
  und weniger kompliziert.
\item
  DataWedge wird von Zebra entwickelt. Damit hat man eine gewisse
  Sicherheit, dass der Scanner verlässlich funktioniert.
\end{itemize}

Bei weiterer Überlegung kommt man außerdem zur Erkenntnis, dass der
Broadcast nicht von DataWedge stammen muss. Wenn eine beliebige andere
App, einen Broadcast mit derselben ID ausschickt, wird die App dies als
Scan werten. In weiterer Folge ist es zumindest theoretisch möglich,
beispielsweise einen Bluetooth-Scanner mit einem regulären Android-Gerät
zu verwenden und bei einem Resultat einen Broadcast mit derselben ID
auszuschicken. Die App würde keinen Unterschied bemerken und somit auch
mit dem Bluetooth-Scanner funktionieren. Dieses Einsatzgebiet wurde vom
Diplomarbeitsteam jedoch nicht getestet.

\hypertarget{zebra-scan-codeausschnitt}{%
\subsection{Zebra-Scan:
Codeausschnitt}\label{zebra-scan-codeausschnitt}}

Broadcast können in Android durch \texttt{BroadcastReceiver} ausgelesen
werden. Auch hier wurde das DRY-Prinzip angewandt. Jedes Fragment, das
Scanergebnisse braucht, verwendet nahezu denselben BroadcastReceiver.
Daher hat das Team einen eigenen BroadcastReceiver erstellt, der die
gemeinsamen Eigenschaften zusammenführt. Der gesamte Code für den
Zebra-Scan konnte damit relativ kompakt in einer Klasse eingebunden
werden:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{class}\NormalTok{ ZebraBroadcastReceiver }\KeywordTok{extends}\NormalTok{ BroadcastReceiver \{}
\NormalTok{    ...}

    \KeywordTok{public} \DataTypeTok{static} \DataTypeTok{void} \FunctionTok{registerZebraReceiver}\NormalTok{(}
                          \BuiltInTok{Context}\NormalTok{ context, }
\NormalTok{                          ZebraBroadcastReceiver zebraBroadcastReceiver, }
                          \BuiltInTok{ErrorHandler}\NormalTok{ errorHandler) \{}
\NormalTok{        ...}
        \CommentTok{// Der BroadcastReceiver muss beim BS registriert werden.}

\NormalTok{        IntentFilter filter = }\KeywordTok{new} \FunctionTok{IntentFilter}\NormalTok{();}
\NormalTok{        filter.}\FunctionTok{addCategory}\NormalTok{(Intent.}\FunctionTok{CATEGORY_DEFAULT}\NormalTok{);}

        \CommentTok{// R.string.activity_intent_filter_action definiert }
        \CommentTok{// die konfigurierte ID des Broadcasts.}
\NormalTok{        filter.}\FunctionTok{addAction}\NormalTok{(}
\NormalTok{            context.}\FunctionTok{getResources}\NormalTok{()}
\NormalTok{            .}\FunctionTok{getString}\NormalTok{(R.}\FunctionTok{string}\NormalTok{.}\FunctionTok{activity_intent_filter_action}\NormalTok{));}

        \CommentTok{// Hier wird der BroadcastReceiver mit der ID, }
        \CommentTok{// auf die er zu hören hat, registriert.}
\NormalTok{        context.}\FunctionTok{registerReceiver}\NormalTok{(zebraBroadcastReceiver, filter);}
\NormalTok{    \}}


    \KeywordTok{public} \DataTypeTok{static} \DataTypeTok{void} \FunctionTok{unregisterZebraReceiver}\NormalTok{(}
                    \BuiltInTok{Context}\NormalTok{ context, }
\NormalTok{                    ZebraBroadcastReceiver zebraBroadcastReceiver) \{}
         \CommentTok{// Falls ein BrodcastReceiver nicht mehr gebraucht wird,}
         \CommentTok{// sollte er immer beim BS abgemeldet werden.}

\NormalTok{        context.}\FunctionTok{unregisterReceiver}\NormalTok{(zebraBroadcastReceiver);}
\NormalTok{    \}}

    \AttributeTok{@Override}
    \KeywordTok{public} \DataTypeTok{void} \FunctionTok{onReceive}\NormalTok{(}\BuiltInTok{Context}\NormalTok{ context, Intent intent) \{}
        \CommentTok{// Falls ein Broadcast eintrifft, }
        \CommentTok{// wird diese Methode aufgerufen.}

        \BuiltInTok{String}\NormalTok{ action = intent.}\FunctionTok{getAction}\NormalTok{();}

        \CommentTok{// R.string.activity_intent_filter_action definiert }
        \CommentTok{// die konfigurierte ID des Broadcasts.}
        \CommentTok{// Somit kann festgestellt werden,}
        \CommentTok{// ob es sich um den richtigen Broadcast handelt.}
        \KeywordTok{if}\NormalTok{ (action.}\FunctionTok{equals}\NormalTok{(context.}\FunctionTok{getResources}\NormalTok{()}
\NormalTok{           .}\FunctionTok{getString}\NormalTok{(R.}\FunctionTok{string}\NormalTok{.}\FunctionTok{activity_intent_filter_action}\NormalTok{))) \{}

            \CommentTok{// R.string.datawedge_intent_key_data }
            \CommentTok{// definiert die ID des Scanergebnises selbst. }
            \CommentTok{// Der Scan liefert auch andere Ergebnisse, }
            \CommentTok{// wie z.B. das Barcodeformat. }
            \CommentTok{// Relevant ist nur der Barcode.}
            \BuiltInTok{String}\NormalTok{ barcode = intent.}\FunctionTok{getStringExtra}\NormalTok{(}
\NormalTok{                context.}\FunctionTok{getResources}\NormalTok{()}
\NormalTok{                .}\FunctionTok{getString}\NormalTok{(R.}\FunctionTok{string}\NormalTok{.}\FunctionTok{datawedge_intent_key_data}\NormalTok{));}

          
            \CommentTok{// Das Scanergebnis wird nun per }
            \CommentTok{// funktionalem Interface an die Fragments weitergegeben.}
\NormalTok{            scanListener.}\FunctionTok{handleZebraScan}\NormalTok{(barcode);}
\NormalTok{        \}}
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{der-kamerascan}{%
\section{Der Kamerascan}\label{der-kamerascan}}

Für Geräte, die nicht dem Hause Zebra entstammen, bietet die App die
Möglichkeit eines Kamerascans an. Im Hintergrund wird dafür die Google
Mobile Vision API verwendet, die unter anderem auch Texterkennung oder
Gesichtserkennung anbietet \cite{mobile-vision}.

Hierbei wird ein Barcode mittels der Gerätekamera erfasst, ohne zuvor
ein Bild machen zu müssen. Dem Benutzer wird eine Preview angezeigt und
die Kamera schließt sich, sobald ein Barcode erfasst wurde. Um die
Performanz zu maximieren, hat das Diplomarbeitsteam folgende
Optimierungen vorgenommen:

\begin{itemize}
\tightlist
\item
  Die API wurde um Blitzfunktionalitäten ergänzt. Dazu wurde eine
  OpenSource-Variante der Library modifiziert, da die offizielle
  proprietäre Version keinen Blitz unterstützt. Der Blitz ist über einen
  \texttt{ToggleButton} sofort deaktivierbar oder aktivierbar. Um einen
  Klick einzusparen, kann der Benutzer über die Einstellungen den Blitz
  gleich beim Start des Kamerascans aktivieren lassen. Für eine optimale
  Erkennung darf man den Blitz jedoch nicht direkt in Richtung des
  Barcode anvisieren, sondern sollte den Blitz entweder höher oder
  niedriger als den Barcode halten, um optische Reflexionen zu
  vermeiden.
\item
  Über die Einstellungen kann der Benutzer die Barcodeformate
  einschränken. Dies führt ebenfalls zur schnelleren Barcodeerkennung
  und vermeidet zudem noch das Auftreten von \texttt{false\ positives}.
  Wenn der Benutzer die Kamera nicht auf den gesamten Barcode hält, kann
  es unter Umständen dazu kommen, dass der abgeschnittene Barcode
  fälschlicherweise als anderes Format interpretiert wird und der Scan
  daher einen Barcode liefert, der nicht existiert. Offiziell wird in
  der vorliegenden Organisation nur das \texttt{Code\_93}-Format
  eingesetzt.
\item
  Interne Test haben ergeben, dass ein Aspect Ratio von 16:9 das
  Schnellste ist. Daher wird die Preview-Größe statisch auf 1920x1080
  Pixel festgelegt. Die Preview verwendet jedoch tatsächlich die Größe,
  die am nähesten zu 1920x1080 ist und vom Gerät unterstützt wird.
\item
  Falls ein Scan erfolgreich ist, wird ein Piepston abgespielt, der als
  akustisches Feedback fungiert.
\end{itemize}

\hypertarget{kamerascan-codeausschnitt}{%
\subsection{Kamerascan:
Codeausschnitt}\label{kamerascan-codeausschnitt}}

Für die Scanfeatures wird bezüglich der Single-Activity-Architektur eine
Ausnahme gemacht. Da diese Screens navigationstechnisch unabhängig sind
und im Vollbildmodus gestartet werden, macht es mehr Sinn, sie als
Activities anstatt als Fragments zu implementieren. Die Fragments, die
einen Kamerascan verwenden, können ihn mit
\texttt{startActivityForResult} aufrufen. Sie starten also eine neue
Activity, um ein Ergebnis zu erhalten:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Intent intent = }\KeywordTok{new} \FunctionTok{Intent}\NormalTok{(}\FunctionTok{getContext}\NormalTok{(), ScanBarcodeActivity.}\FunctionTok{class}\NormalTok{);}
\CommentTok{// 0 ist der Request Code, der die Aktivität identifiziert. }
\FunctionTok{startActivityForResult}\NormalTok{(intent, }\DecValTok{0}\NormalTok{);}
\end{Highlighting}
\end{Shaded}

Mit der Vision API erstellt man einen \texttt{BarcodeDetector} dem ein
\texttt{Processor} zugewiesen wird. Falls ein Barcode erkannt wird, wird
\texttt{receiveDetections} automatisch aufgerufen. Die App nimmt sich
den ersten erkannten Barcode heraus, setzt ihn als Ergebnis dieser
Aktivität und beendet die Aktivität.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{barcodeDetector.}\FunctionTok{setProcessor}\NormalTok{(}\KeywordTok{new}\NormalTok{ Detector.}\FunctionTok{Processor}\NormalTok{<Barcode>() \{}

     \AttributeTok{@Override}
    \KeywordTok{public} \DataTypeTok{void} \FunctionTok{receiveDetections}\NormalTok{(}
\NormalTok{                        Detector.}\FunctionTok{Detections}\NormalTok{<Barcode> detections) \{}
\NormalTok{           ...}
           \CommentTok{// Barcode einlesen}
           \BuiltInTok{String}\NormalTok{ barcode = barcodeSparseArray.}\FunctionTok{valueAt}\NormalTok{(}\DecValTok{0}\NormalTok{).}\FunctionTok{rawValue}\NormalTok{;}

           \CommentTok{//Barcode bekanntgeben}
\NormalTok{           Intent intent = }\KeywordTok{new} \FunctionTok{Intent}\NormalTok{();}
\NormalTok{           intent.}\FunctionTok{putExtra}\NormalTok{(}\StringTok{"barcode"}\NormalTok{, barcode);}
           \FunctionTok{setResult}\NormalTok{(CommonStatusCodes.}\FunctionTok{SUCCESS}\NormalTok{, intent);}
           \FunctionTok{finish}\NormalTok{();}
\NormalTok{           ...}
\NormalTok{    \}}
\NormalTok{    ...}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Das Ergebnis kann dann wiederum im Fragment wie folgt abgefangen und
weiterverarbeitet werden:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{@Override}
\KeywordTok{public} \DataTypeTok{void} \FunctionTok{onActivityResult}\NormalTok{(}\DataTypeTok{int}\NormalTok{ requestCode, }\DataTypeTok{int}\NormalTok{ resultCode, }
                             \AttributeTok{@Nullable}\NormalTok{ Intent data) \{}
    \KeywordTok{if}\NormalTok{ (requestCode == }\DecValTok{0}\NormalTok{) \{}
        \KeywordTok{if}\NormalTok{ (resultCode == CommonStatusCodes.}\FunctionTok{SUCCESS}\NormalTok{) \{}
            \KeywordTok{...    }
            \CommentTok{// Barcode einlesen}
            \BuiltInTok{String}\NormalTok{ barcode = data.}\FunctionTok{getStringExtra}\NormalTok{(}\StringTok{"barcode"}\NormalTok{);}
            \CommentTok{// Anhand des Barcodes werden dann }
            \CommentTok{// weitere Aktionen gesetzt}
            \FunctionTok{launchDetailedItemFragmentFromBarcode}\NormalTok{(barcode);}
\NormalTok{        \}}
\NormalTok{        ...}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{die-manuelle-eingabe}{%
\section{Die manuelle Eingabe}\label{die-manuelle-eingabe}}

Gegenstände können durch Scannen, aber auch durch manuelles Klicken auf
ihre GUI-Darstellung validiert werden. Es kann durchaus Sinn machen, auf
einen Scan zu verzichten, wenn:

\begin{itemize}
\tightlist
\item
  der Scan langsam oder unmöglich ist (\zB bei Barcodes in
  unerreichbarer Höhe oder beschädigten Barcodes).
\item
  man einen Gegenstand auch ohne Barcode identifizieren kann.
\item
  man mit einer manuellen Vorgehensweise schneller ist, als mit dem
  Kamerascan.
\end{itemize}

\hypertarget{suche}{%
\subsection{Suche}\label{suche}}

Die Gegenstandsliste, die dem Benutzer angezeigt wird, ist durch eine
Suchleiste (\texttt{SearchBar}) filterbar. Der Benutzer kann nach
Barcode und Gegenstandsbeschreibung filtern. Dadurch ergibt sich auch
die Möglichkeit, eine Voice-Tastatur -- insofern das Gerät eine hat --
einzusetzen.

\hypertarget{textscan}{%
\subsection{Textscan}\label{textscan}}

Falls der Benutzer weder Voice noch Tastatur verwenden will, kann er den
Textscan verwenden. Hierbei wird per Google Mobile Vision API der
aufgedruckte Text auf einem Barcode -- jedoch NICHT der Barcode selbst
-- gescannt \cite{text-scan}. Dem Benutzer wird das aktuelle
Scanergebnis laufend angezeigt.

Da der Out-Of-The-Box-Scan für die vorliegenden Zwecke nicht unbedingt
geeignet ist, wurden folgende Modifikationen vorgenommen:

\begin{itemize}
\tightlist
\item
  Die API wurde um Blitzfunktionalitäten ergänzt.
\item
  Der Scanner gibt grundsätzlich alles was er sieht wieder. Das
  Projektteam hat dies mit \texttt{Regex}-Ausdrücken kombiniert um
  sinnvolle Ergebnisse zu erlangen. Es gibt daher verschiedene
  Texterkennungsmodi:

  \begin{itemize}
  \tightlist
  \item
    Kein Filter. Hier wird keine Regex verwendet und der Benutzer sieht
    den ungefilterten Text, den der Scanner erkannt hat.
  \item
    Alphanumerisch.
  \item
    Alphabetisch.
  \item
    Numerisch (Barcodes).
  \item
    IP-Adressen.
  \end{itemize}
\end{itemize}

Jeder Modus verwendet die Regex, die am besten für seine Kategorie
geeignet ist. Die Library bietet nur geringfügige Möglichkeiten an, den
Scan selbst zu beeinflussen. Man kann lediglich einen Fokus auf ein
Scanergebnis setzen. Daher wird der Fokus auf ein Scanergebnis gesetzt,
sobald dieses durch die aktuelle Regex ausgedrückt werden kann. Die API
beschränkt sich allerdings nicht auf das Ergebnis, auf das der Fokus
gesetzt wurde, sondern kann jederzeit den Fokus selbst wieder aufheben.
Unabhängig davon werden alle Zeichen des Ergebnisses entfernt, die nicht
durch die Regex erfasst wurden.

Die Erkennung von Barcodes (also der Numerische Modus) hat zusätzlich
folgende Optimierungen erhalten:

\begin{itemize}
\tightlist
\item
  Gescannte Ergebnisse werden durch die Regex optimiert und gespeichert.
  Das Ergebnis, das zuerst dreimal vorkam, wird eingelockt. Das heißt,
  dass alle restlichen Scans ignoriert werden.
\item
  Zeichen die häufig vom Scanner verwechselt werden (\zB wird die Ziffer
  ``0'' häufig als Buchstabe ``O'' erkannt), werden durch ihr
  numerisches Gegenstück ersetzt.
\item
  Längere Zeichenketten erhalten eine höhere Priorität und werden dem
  Benutzer vorzugsweise angezeigt. Damit werden abgeschnittene
  Ergebnisse benachteiligt. Falls ein kürzeres Ergebnis jedoch dreimal
  vorkommt, wird nicht mehr die längste Zeichenkette, sondern die
  häufigste bevorzugt und dem Benutzer angezeigt.
\item
  Ergebnisse, die weniger als sieben Zeichen enthalten, werden nicht
  gespeichert und können damit auch nicht eingelockt werden.
\end{itemize}

Der Benutzer kann das aktuell angezeigte Ergebnis in seine
Zwischenablage kopieren und anschließend die Suchleiste nutzen. Die
Kommunikation zwischen den Fragments und dem Textscan erfolgt analog zum
Kamerascan, da der Textscan aus denselben Gründen als Activity
implementiert wurde.
