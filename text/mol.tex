\chapter{Einführung in die Server-Architektur}

Die Inventur- sowie Gegenstandsdaten der HTL Rennweg sollen an einem
zentralen Ort verwaltet und geführt werden. Der für diesen Zweck
entwickelte Server muss also folgende Anforderungen erfüllen:

\begin{itemize}
\tightlist
\item
  eine einfache Datenbankverwaltung und -verbindung
\item
  das Führen einer Historie aller Zustände der Inventar-Gegenstände
\item
  eine Grundlage für eine Web-Administrationsoberfläche
\item
  die Möglichkeit für Datenimport und -export, etwa als
  \emph{.xlsx}\index{.xlsx: Format einer Excel Datei} Datei
\item
  eine Grundlage für die Kommunikation mit der Client-Applikation
\item
  hohe Stabilität und Verfügbarkeit
\end{itemize}

Angesichts der Programmiersprachen, in die das Projektteam spezialisiert
ist, stehen als Backend-Lösung vier
\emph{Frameworks}\index{Framework: Eine softwaretechnische Architektur, die bestimmte Funktionen und Klassen zur Verfügung stellt}
zur öffentlichen Verfügung, zwischen denen gewählt wurde:

\begin{itemize}
\tightlist
\item
  Django \cite{django}
\item
  Pyramid \cite{pyramid}
\item
  Web2Py \cite{web2py}
\item
  Flask \cite{flask}
\end{itemize}

Alle genannten Alternativen sind
\emph{Frameworks}\index{Framework: Eine softwaretechnische Architektur, die bestimmte Funktionen und Klassen zur Verfügung stellt}
der Programmiersprache Python. Gewählt wurde ``Django'' aufgrund einer
bestehenden und frei verfügbaren Inventarverwaltungsplattform ``Ralph''
\cite{ralph}, die auf Django aufbaut und durch die vorliegende
Diplomarbeit hinreichend erweitert wird.

\hypertarget{django-und-ralph}{%
\section{Django und Ralph}\label{django-und-ralph}}

Django ist ein in der Programmiersprache Python geschriebenes
Webserver-\emph{Framework}\index{Framework: Eine softwaretechnische Architektur, die bestimmte Funktionen und Klassen zur Verfügung stellt}.
Ralph ist eine auf dem
Django-\emph{Framework}\index{Framework: Eine softwaretechnische Architektur, die bestimmte Funktionen und Klassen zur Verfügung stellt}
basierende
\emph{DCIM}\index{DCIM: Data Center Infrastructure Management - Software, die zur Verwaltung von Rechenzentren entwickelt wird }
und
\emph{CMDB}\index{CMDB: Configuration Management Database - Eine Datenbank, die für die Konfiguration von IT-Geräten entwickelt ist \cite{cmdb}}
Softwarelösung. Haupteinsatzgebiet dieser Software sind vor allem
Rechenzentren mit hoher Komplexität, die externe Verwaltungsplattformen
benötigen. Zusätzlich können aber auch herkömmliche Inventardaten von
IT-spezifischen Gegenständen in die Ralph-Plattform aufgenommen werden.

Ralph wurde von der polnischen Softwarefirma ``Allegro'' entwickelt und
ist unter der Apache 2.0 Lizenz öffentlich verfügbar. Dies ermöglicht
auch Veränderungen und Erweiterungen. Zu Demonstrationszwecken bietet
Allegro eine öffentlich nutzbare Demo-Version \cite{ralph-demo} von
Ralph an.

Die vorliegende Diplomarbeit bietet eine Erweiterung des Ralph-Systems.

\hypertarget{begruxfcndung-der-wahl-von-django-und-ralph}{%
\subsection{Begründung der Wahl von Django und
Ralph}\label{begruxfcndung-der-wahl-von-django-und-ralph}}

Django bietet eine weit verbreitete Open-Source Lösung für die
Entwicklung von Web-Diensten. Bekannte Webseiten, die auf Django
basieren sind u.a. Instagram, Mozilla, Pinterest und Open Stack.
\cite{django-overview} Django zeichnet sich besonders durch die sog.
\emph{"Batteries included"}\index{Batteries included: Das standardmäßige Vorhandensein von erwünschten bzw. gängigen \emph{Features}\index{Feature: Eigenschaft bzw. Funktion eines Systems}, zu Deutsch: Batterien einbezogen}
Mentalität aus. Das heißt, dass Django bereits die gängigsten
\emph{Features}\index{Feature: Eigenschaft bzw. Funktion eines Systems}
eines Webserver-Backends standardmäßig innehat. Diese sind (im Vergleich
zu Alternativen wie etwa ``Flask'') u.a.:

\begin{itemize}
\tightlist
\item
  Authentifikation und Autorisierung, sowie eine damit verbundene
  Benutzerverwaltung
\item
  Schutz vor gängigen Attacken (wie
  \emph{SQL-Injections}\index{SQL-Injections: klassischer Angriff auf ein Datenbanksystem}
  oder
  \emph{CSRF}\index{CSRF: Cross-Site-Request-Forgery - eine Angriffsart, bei dem ein Opfer dazu gebracht wird, eine von einem Angreifer gefälschte Anfrage an einen Server zu schicken \cite{csrf}}\cite{csrf}),
  siehe \protect\hyperlink{views}{Views}
\end{itemize}

Zusätzlich bietet Ralph bereits einige
\emph{Features}\index{Feature: Eigenschaft bzw. Funktion eines Systems},
die die grundlegende Führung und Verwaltung eines herkömmlichen
Inventars unterstützen (beispielsweise eine Suchfunktion mit
automatischer Textvervollständigung).

\hypertarget{kurzfassung-der-funktionsweise-von-django-und-rlaph}{%
\section{Kurzfassung der Funktionsweise von Django und
Rlaph}\label{kurzfassung-der-funktionsweise-von-django-und-rlaph}}

Im folgenden Kapitel wird die Funktionsweise des
Django-\emph{Frameworks}\index{Framework: Eine softwaretechnische Architektur, die bestimmte Funktionen und Klassen zur Verfügung stellt},
sowie Ralph beschrieben. Ziel dieses Kapitels ist es, eine Wissensbasis
für die darauffolgenden Kapitel zu schaffen.

\hypertarget{datenbank-verbindung-pakete-und-tabellen-definition}{%
\subsection{Datenbank-Verbindung, Pakete und
Tabellen-Definition}\label{datenbank-verbindung-pakete-und-tabellen-definition}}

Folgende Datenbank-Typen werden von Django unterstützt:

\begin{itemize}
\tightlist
\item
  PostgreSQL
\item
  MariaDB
\item
  MySQL
\item
  Oracle
\item
  SQLite
\end{itemize}

Die Konfiguration der Datenbank-Verbindung geschieht unter
Standard-Django in der Datei \texttt{settings.py} , unter Ralph in der
jeweiligen Datei im Verzeichnis \texttt{settings}. Eine detaillierte
Anleitung zur Verbindung mit einer Datenbank ist in der offiziellen
Django-Dokumentation \cite{django-doku-db} zu finden.

Die verschiedenen Funktionsbereiche des Servers sind in Pakete bzw.
Module gegliedert. Jedes Paket ist ein Ordner, der verschiedene Dateien
und Unterordner beinhalten kann. Die Dateinamen-Nomenklatur eines
Packets ist normiert.\cite{django-file-nomenklatur} Der Name eines
Pakets wird fortan ``App-Label'' genannt. Standardmäßig ist dieser Name
erster Bestandteil einer URL zu einer beliebigen graphischen
Administrationsoberfläche des Pakets. Pakete werden durch einen Eintrag
in die Variable \texttt{INSTALLED\_APPS} innerhalb der o.a.
Einstellungsdatei registriert. Beispiele sind die beiden durch die
vorliegende Diplomarbeit registrierten Pakete \texttt{"ralph.capentory"}
und \texttt{"ralph.stocktaking"}

Ist ein Python-Paket erfolgreich registriert, können in der Datei
\texttt{models.py} Datenbank-Tabellen als python Klassen\footnote{erbend
  von der Superklasse \texttt{Model}\cite{django-doku-models}} definiert
werden. Diese Klassen werden fortan als ``Modell'' bezeichnet.
Tabellenattribute werden als Attribute dieser Klassen definiert und sind
jeweils Instanzen der Klasse
\texttt{Field}\cite{django-doku-models}\footnote{oder davon erbende
  Klassen}. Datenbankeinträge können demnach als Instanzen der
Modellklassen betrachtet und behandelt werden. Standardmäßig besitzt
jedes Modell ein Attribut \texttt{id}, welches als
\emph{primärer Schlüssel}\index{primärer Schlüssel: engl. "primary key", abgek. "pk" - ein Attribut, das einen Datensatz eindeutig identifiziert}
dient. Der Wert des \texttt{id} Attributs ist unter allen Instanzen
eines Modells einzigartig. Die Anpassung dieses Attributs wird in der
offiziellen Django-Dokumentation genauer behandelt.
\cite{django-doku-models}

Jedes Modell benötigt eine innere Klasse \texttt{Meta}. Sie beschreibt
die
\emph{Metadaten}\index{Metadaten: Daten, die einen gegebenen Datensatz beschreiben, beispielsweise der Autor eines Buches}
der Modellklasse. Dazu gehört vor allem der von Benutzern lesbare Name
des Modells \texttt{verbose\_name}. \cite{django-doku-models-options}

\hypertarget{administration-uxfcber-das-webinterface}{%
\subsection{Administration über das
Webinterface}\label{administration-uxfcber-das-webinterface}}

Um die Administration von Modelldaten über das Webinterface des Servers
zu ermöglichen, werden grundsätzlich zwei Ansichten der Daten benötigt:
Eine Listenansicht aller Datensätze und eine Detailansicht einzelner
Datensätze.

Die Listenansicht aller Datensätze eines Modells wird in der Datei
\texttt{admin.py} als
\emph{Subklasse}\index{Subklasse: Eine programmiertechnische Klasse, die eine übergeordnete Klasse, auch "Superklasse", erweitert oder verändert, indem sie alle Attribute und Methoden der Superklasse erbt}
von \texttt{ModelAdmin}\footnote{Unter Ralph steht hierfür die Klasse
  \texttt{RalphAdmin} zur Verfügung.\cite{ralph-admin-doku}} definiert.
Attribute dieser Klasse beeinflussen das Aussehen und die Funktionsweise
der Weboberfläche. Durch das Setzen von \texttt{list\_display} werden
beispielsweise die in der Liste anzuzeigenden Attribute definiert.

Die Detailansicht einzelner Datensätze wird grundsätzlich durch die
\texttt{ModelAdmin} Klasse automatisch generiert, kann aber durch Setzen
dessen \texttt{form} Attributs auf eine eigens definierte
\emph{Subklasse}\index{Subklasse: Eine programmiertechnische Klasse, die eine übergeordnete Klasse, auch "Superklasse", erweitert oder verändert, indem sie alle Attribute und Methoden der Superklasse erbt}
von \texttt{ModelForm}\footnote{Unter Ralph steht hierfür die Klasse
  \texttt{RalphAdminForm} zur Verfügung.} angepasst werden. Diese
Klassen werden in der Datei \texttt{forms.py} definiert und besitzen,
ähnlich der \texttt{Model} Klasse, auch eine innere Klasse
\texttt{Meta}.

Um die \texttt{ModelAdmin}
\emph{Subklassen}\index{Subklasse: Eine programmiertechnische Klasse, die eine übergeordnete Klasse, auch "Superklasse", erweitert oder verändert, indem sie alle Attribute und Methoden der Superklasse erbt}
über eine URL erreichbar zu machen, müssen diese registriert werden.
Dies geschieht durch den \texttt{register}
\emph{Dekorator}\index{Dekorator: Fügt unter Python einer Klasse oder Methode eine bestimmte Funktionsweise hinzu \cite{python-decorators}}.
Dieser Dekorator akzeptiert die zu registrierende Modellklasse, die zu
dem \texttt{ModelAdmin} gehört, als Parameter. Die Listenansicht einer
registrierten \texttt{ModelAdmin} Subklasse ist standardmäßig unter der
URL

\begin{verbatim}
/<App-Label>/<Modell-Name>/
\end{verbatim}

erreichbar, die Detailansicht einer Modellinstanz unter der URL

\begin{verbatim}
/<App-Label>/<Modell-Name>/<Modellinstanz-ID>/
\end{verbatim}

. Somit repräsentiert die URL der Listenansicht gleichzeitig den Pfad,
unter der sie definiert wurde.

Die Dokumentation der Administrationsfeatures von Django ist auf der
offiziellen Dokumentationswebseite von Django \cite{django-doku-admin}
zu finden.

\hypertarget{api-und-drf}{%
\subsection{API und DRF}\label{api-und-drf}}

Um Daten außerhalb der graphischen Administrationsoberfläche zu
bearbeiten, wird eine
\emph{API}\index{API: Application-Programming-Interface - Eine Schnittstelle, die die programmiertechnische Erstellung, Bearbeitung und Einholung  von Daten auf einem System ermöglicht}
benötigt. Eine besondere und weit verbreitete Form einer API ist eine
\emph{REST-API}
\index{REST-API: Representational State Transfer \emph{API}\index{API: Application-Programming-Interface - Eine Schnittstelle, die die programmiertechnische Erstellung, Bearbeitung und Einholung  von Daten auf einem System ermöglicht} - eine zustandslose Schnittstelle für den Datenaustausch zwischen Clients und Servern \cite{rest-api}}
\cite{rest-api}, die unter Django durch das integrierte
\emph{DRF}\index{DRF: Django REST Framework - Implementierung einer \emph{REST-API}\index{REST-API: Representational State Transfer \emph{API}\index{API: Application-Programming-Interface - Eine Schnittstelle, die die programmiertechnische Erstellung, Bearbeitung und Einholung  von Daten auf einem System ermöglicht} - eine zustandslose Schnittstelle für den Datenaustausch zwischen Clients und Servern \cite{rest-api}} unter Django \cite{django-rest-framework}}
implementiert wird.\cite{django-rest-framework} API Definitionen werden
unter Django in einem Paket in der Datei \texttt{api.py} getätigt.

Um den API-Zugriff auf ein Modell zu ermöglichen werden üblicherweise
eine \texttt{APIView}\footnote{Unter Ralph steht hierfür die Klasse
  \texttt{RalphAPISerializer} zur Verfügung. \cite{ralph-api-doku}}
\emph{Subklasse}\index{Subklasse: Eine programmiertechnische Klasse, die eine übergeordnete Klasse, auch "Superklasse", erweitert oder verändert, indem sie alle Attribute und Methoden der Superklasse erbt}
und eine \texttt{Serializer}\footnote{Unter Ralph steht hierfür die
  Klasse \texttt{RalphAPIViewSet} zur Verfügung. \cite{ralph-api-doku}}
\emph{Subklasse}\index{Subklasse: Eine programmiertechnische Klasse, die eine übergeordnete Klasse, auch "Superklasse", erweitert oder verändert, indem sie alle Attribute und Methoden der Superklasse erbt}
definiert. \texttt{APIView} Klassen sind zuständig für das Abarbeiten
von Anfragen mithilfe einer \texttt{Serializer} Klasse, die die Daten
aus der Datenbank repräsentiert und in das gewünschte Format
konvertiert. Durch \texttt{APIView} Klassen werden Berechtigungen und
sonstige Attribute definiert, die sich auf das wahrgenommene
Erscheinungsbild des Servers auf einen Client auswirken. Beispiel dafür
ist die Art der \emph{Paginierung}
\cite{django-rest-framework}\index{Paginierung: engl. pagination - Die Aufteilung von Datensätzen in diskrete Seiten \cite{django-rest-framework-pagination}}.
Die erstellten \texttt{APIView} Klassen können dann mithilfe einer
\texttt{Router}\footnote{Unter Ralph steht hierfür die globale
  \texttt{RalphRouter} Instanz \texttt{router} zur Verfügung.
  \cite{ralph-api-doku}} Instanz registriert werden. Anleitungen zur
Erstellung dieser API-Klassen sind auf der offiziellen Webseite des DRF
\cite{django-rest-framework} und der offiziellen
Ralph-Dokumentationsseite \cite{ralph-api-doku} zu finden.

\hypertarget{views}{%
\subsection{Views}\label{views}}

Schnittstellen, die keiner der beiden o.a. Kategorien zugeordnet werden
können, werden in der Datei \texttt{views.py} definiert. Bei diesen
\emph{generischen}\index{generisch: in einem allgemeingültigen Sinn}
Schnittstellen handelt es sich entweder um
\emph{Subklassen}\index{Subklasse: Eine programmiertechnische Klasse, die eine übergeordnete Klasse, auch "Superklasse", erweitert oder verändert, indem sie alle Attribute und Methoden der Superklasse erbt}
der Klasse \texttt{View}\footnote{die ebenfalls Superklasse der Klasse
  \texttt{ApiView} ist} \cite{django-doku-class-based-views} oder
vereinzelte Methoden mit einem \texttt{request}\footnote{zu Deutch:
  Anfrage; entspricht dem empfangenen Packet, meist als HTML.}
Parameter. \cite{django-doku-views} Diese Schnittstellen werden fortan
Views genannt.

Soll ein View als Antwort auf eine Anfrage HTML-Daten liefern, so sollte
dazu ein \emph{Template}\index{Template: zu Deutch: Vorlage, Schablone}
verwendet werden. Mithilfe von Templates können Daten, die etwa durch
Datenbankabfrage entstehen, zu einer HTML Antwort aufbereitet werden.
Besonders ist hierbei die zusätzlich zu HTML verfügbare
Django-Template-\emph{Syntax}\index{Syntax: Regelwerk, sprachliche Einheiten miteinander zu verknüpfen \cite{syntax}}
\cite{django-doku-template}. Damit können HTML Elemente auf den
Input-Daten basierend dynamisch generiert werden. So stehen
beispielsweise \texttt{if} Statements direkt in der Definition des
Templates zur Verfügung. Die Benutzung von Templates schützt
standardmäßig gegen gängige Attacken, wie
\emph{SQL-Injections}\index{SQL-Injections: klassischer Angriff auf ein Datenbanksystem}
oder \emph{CSRF}
\index{CSRF: Cross-Site-Request-Forgery - eine Angriffsart, bei dem ein Opfer dazu gebracht wird, eine von einem Angreifer gefälschte Anfrage an einen Server zu schicken \cite{csrf}}\cite{csrf}
und gilt daher als besonders sicher.

Da reguläre Views nicht automatisch registriert werden, müssen sie
manuell bekanntgegeben werden. Dies geschieht durch einen Eintrag in die
Variable \texttt{urlpatterns} in der Datei \texttt{urls.py}.
\cite{django-doku-urls}

\hypertarget{datenbankabfragen}{%
\subsection{Datenbankabfragen}\label{datenbankabfragen}}

Datenbankabfragen werden in Django durch \texttt{Queryset}-Objekte
getätigt. Das Definieren eines \texttt{Queryset}-Objekts löst nicht
sofort eine Datenbankabfrage aus. Erst, wenn Werte aus einem
\texttt{Queryset}-Objekt gelesen werden, wird eine Datenbankabfrage
ausgelöst. So kann ein \texttt{Queryset}-Objekt beliebig oft verändert
werden, bevor davon ausgelesen wird. Ein Beispiel hierfür ist das
Anwenden der \texttt{filter()} Methode.

In dem folgenden Code-Auszug\footnote{entnommen aus der offiziellen
  Django Dokumentation \cite{django-doku-queries}} werden aus dem Modell
\texttt{Entry} bestimmte Einträge gefiltert:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Erstelle ein Queryset aller Entry{-}Objekte, }
\CommentTok{\# dessen Attribut "headline" mit "What" beginnt.}
\NormalTok{q }\OperatorTok{=}\NormalTok{ Entry.objects.}\BuiltInTok{filter}\NormalTok{(headline\_\_startswith}\OperatorTok{=}\StringTok{"What"}\NormalTok{)}

\CommentTok{\# Filtere aus dem erstellten Queryset alle Entry{-}Objekte, }
\CommentTok{\# dessen Attribut "pub\_date" kleiner oder gleich }
\CommentTok{\# dem aktuellen Datum ist.}
\NormalTok{q }\OperatorTok{=}\NormalTok{ q.}\BuiltInTok{filter}\NormalTok{(pub\_date\_\_lte}\OperatorTok{=}\NormalTok{datetime.date.today())}

\CommentTok{\# Schließe aus dem erstellten Queryset alle Entry{-}Objekte, }
\CommentTok{\# dessen Attribut "body\_text" den Text "food" beinhaltet, aus.}
\NormalTok{q }\OperatorTok{=}\NormalTok{ q.exclude(body\_text\_\_icontains}\OperatorTok{=}\StringTok{"food"}\NormalTok{)}

\CommentTok{\# Ausgabe des erstellten Querysets.}
\CommentTok{\# Erst hier kommt es zu der ersten Datenbankabfrage!}
\BuiltInTok{print}\NormalTok{(q)}
\end{Highlighting}
\end{Shaded}

Weitere Beispiele und Methoden sind der offiziellen Django-Dokumentation
zu entnehmen. \cite{django-doku-queries}

\hypertarget{designgrundlagen}{%
\section{Designgrundlagen}\label{designgrundlagen}}

Designgrundlagen für Django-Entwickler sind auf der offiziellen
Dokumentationsseite von Django abrufbar. \cite{django-doku-coding-style}
Die Erweiterung von Django durch die vorliegende Diplomarbeit wurde
anhand dieser Grundlagen entwickelt.

Das Konzept des \texttt{Mixin}s wird von der Ralph-Plattform besonders
häufig genutzt. \texttt{Mixin}s sind Klassen, die anderen von ihnen
erbende Klassen, bestimmte Attribute und Methoden hinzufügen. Manche
\texttt{Mixin}s setzen implizit voraus, dass die davon erbenden Klassen
ebenfalls von bestimmten anderen Klassen erben. Beispiel ist die Klasse
\texttt{AdminAbsoluteUrlMixin}, die eine Methode
\texttt{get\_absolute\_url} zur Verfügung stellt. Diese Methode liefert
die URL, die zu der Detailansicht der Modellinstanz führt, die die
Methode aufruft. Voraussetzung für das Erben einer Klasse von
\texttt{AdminAbsoluteUrlMixin} ist daher, dass sie ebenfalls von der
Klasse \texttt{Model} erbt.

\chapter{Die 2 Erweiterungsmodule des Serverssystems}

Die vorliegende Diplomarbeit erweitert das
\protect\hyperlink{django-und-ralph}{``Ralph''} System um 2 Module.
Dabei handelt es sich um die beiden Pakete ``Capentory'' und
``Stocktaking''. Das Paket ``Capentory'' behandelt die Führung der
Inventardaten und wurde speziell an die Inventardaten der HTL Rennweg
angepasst. Das Paket ``Stocktaking'' ermöglicht die Verwaltung der durch
die mobile Applikation durchgeführten Inventuren. Dazu zählen Aufgaben
wie das Erstellen der Inventuren, das Einsehen von Inventurberichten
oder das Anwenden der aufgetretenen Änderungen.

Dieses Kapitel beschreibt die grundlegende Funktionsweise der beiden
Module. Die Bedienung der \emph{Weboberfläche}
\index{Weboberfläche: graphische Oberfläche für administrative Tätigkeiten, die über einen Webbrowser erreichbar ist}
ist dem \todo{Add reference} Handbuch zum Server zu entnehmen.

\hypertarget{das-capentory-modul}{%
\section{Das ``Capentory'' Modul}\label{das-capentory-modul}}

Das ``Capentory'' Modul beherbergt 3 wichtige Modelle:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  HTLItem
\item
  HTLRoom
\item
  HTLItemType
\end{enumerate}

Die wichtigsten Eigenschaften der Modelle und damit verbundenen
Funktionsweisen werden in diesem Unterkapitel beschrieben.

\hypertarget{das-htlitem-modell}{%
\subsection{Das HTLItem Modell}\label{das-htlitem-modell}}

Das \texttt{HTLItem}-Modell repräsentiert die Gegenstandsdaten des
Inventars der HTL Rennweg. Es sind typische Merkmale aus dem
\emph{SAP ERP}
\index{SAP ERP: Enterprise-Resource-Planning Software der Firma SAP. Damit können Unternehmen mehrere Bereiche wie beispielsweise Inventardaten oder Kundenbeziehungen zentral verwalten}
System vertreten. Die Attribute \texttt{anlage},
\texttt{asset\_subnumber} und \texttt{company\_code} werden direkt aus
dem \emph{SAP ERP}
\index{SAP ERP: Enterprise-Resource-Planning Software der Firma SAP. Damit können Unternehmen mehrere Bereiche wie beispielsweise Inventardaten oder Kundenbeziehungen zentral verwalten}
System übernommen.

\hypertarget{die-wichtigsten-attribute}{%
\subsubsection{Die wichtigsten
Attribute}\label{die-wichtigsten-attribute}}

Zu den wichtigsten Attributen des \texttt{HTLItem} Modells zählen u.a.:

\begin{itemize}
\tightlist
\item
  \texttt{anlage} und \texttt{asset\_subnumber}: Diese Attribute bilden
  den Barcode eines Gegenstandes.
\item
  \texttt{barcode\_prio}: Wenn dieses Attribut gesetzt ist, überschreibt
  es den durch die Attribute \texttt{anlage} und
  \texttt{asset\_subnumber} entstandenen Barcode.
\item
  \texttt{anlagenbeschreibung}: Dieses Attribut repräsentiert die aus
  dem \emph{SAP ERP}
  \index{SAP ERP: Enterprise-Resource-Planning Software der Firma SAP. Damit können Unternehmen mehrere Bereiche wie beispielsweise Inventardaten oder Kundenbeziehungen zentral verwalten}
  System entnommene Gegenstandsbeschreibung und kann nur durch den
  Import von Daten direkt aus dem \emph{SAP ERP}
  \index{SAP ERP: Enterprise-Resource-Planning Software der Firma SAP. Damit können Unternehmen mehrere Bereiche wie beispielsweise Inventardaten oder Kundenbeziehungen zentral verwalten}
  System geändert werden.
\item
  \texttt{anlagenbeschreibung\_prio}: Dieses Attribut dient als interne
  Gegenstandsbeschreibung, die auch ohne einen Import aus dem
  \emph{SAP ERP}
  \index{SAP ERP: Enterprise-Resource-Planning Software der Firma SAP. Damit können Unternehmen mehrere Bereiche wie beispielsweise Inventardaten oder Kundenbeziehungen zentral verwalten}
  System geändert werden kann.
\item
  \texttt{room}: Dieses Attribut referenziert auf ein \texttt{HTLRoom}
  Objekt, in dem sich ein \texttt{HTLItem} Objekt befindet.
\item
  \texttt{is\_in\_sap}: Der Wert dieses
  \emph{Boolean}\index{Boolean: Ein Wert, der nur "Wahr" oder "Falsch" sein kann}-Attributs
  ist \texttt{Wahr}, wenn der \texttt{HTLItem}-Datensatz aus dem
  \emph{SAP ERP}
  \index{SAP ERP: Enterprise-Resource-Planning Software der Firma SAP. Damit können Unternehmen mehrere Bereiche wie beispielsweise Inventardaten oder Kundenbeziehungen zentral verwalten}
  System importiert wurde. Umgekehrt ist der Wert dieses Attributes
  \texttt{Falsch}, wenn der \texttt{HTLItem}-Datensatz aus einer anderen
  Quelle entstanden ist. Ein manuell hinzugefügter
  \texttt{HTLItem}-Datensatz hat für dieses Attribut den Wert
  \texttt{Falsch}.
\item
  \texttt{item\_type}: Dieses Attribut referenziert auf das
  \texttt{HTLItemType} Objekt, das einem \texttt{HTLItem} Objekts
  zugeordnet ist. Es repräsentiert die Gegenstandskategorie eines
  \texttt{HTLItem} Objekts.
\end{itemize}

\hypertarget{einzigartigkeit-von-htlitem-objekten}{%
\subsubsection{Einzigartigkeit von HTLItem
Objekten}\label{einzigartigkeit-von-htlitem-objekten}}

Bezüglich der Einzigartigkeit von \texttt{HTLItem} Objekten gelten
einige Bestimmungen.

Sind die Attribute \texttt{anlage}, \texttt{asset\_subnumber} und
\texttt{company\_code} je mit einem nichtleeren Wert befüllt, so
repräsentieren sie ein \texttt{HTLItem} Objekt eindeutig. Es dürfen
keine 2 \texttt{HTLItem} Objekte denselben Wert dieser Attribute haben.
Um diese Bedingung erfüllen zu können muss eine eigens angepasste
Validierungslogik implementiert werden. Standardverfahren wäre in diesem
Anwendungsfall, die Metavariable \texttt{unique\_together}
\cite{django-doku-models-options} anzupassen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{unique\_together }\OperatorTok{=}\NormalTok{ [[}\StringTok{"anlage"}\NormalTok{,  }\StringTok{"asset\_subnumber"}\NormalTok{, }\StringTok{"company\_code"}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

Dieses Verfahren erfüllt nicht die geforderte Bedingung nur in der
Theorie. Praktisch werden leere Werte von Attributen dieser Art nicht
als \texttt{None} (Python) bzw. \texttt{null} (MySQL), sondern als
Leerstrings \texttt{""} gespeichert. Um diese Werte ebenfalls von der
Regel auszuschließen, muss die \texttt{validate\_unique()}\footnote{Eine
  Methode einer Modell-Klasse, die unter Normalzuständen immer vor dem
  Speichern eines Objekts des Modells aufgerufen wird. Wirft sie einen
  Fehler auf, kann das Objekt nicht gespeichert werden.} Methode
\cite{django-doku-models-instances} überschrieben werden.

Ist das \texttt{barcode\_prio} Attribut eines \texttt{HTLItem} Objekts
gesetzt, darf dessen Wert nicht mit jenem eines anderen \texttt{HTLItem}
Objekts übereinstimmen. Standardverfahren wäre in diesem Anwendungsfall
das Setzen des \texttt{unique} Parameters des Attributes auf den Wert
\texttt{True}. Da dieses Verfahren ebenfalls das o.a. Problem aufwirft,
muss die Logik stattdessen in die \texttt{validate\_unique()} Methode
aufgenommen werden. Zusätzlich darf der Wert des \texttt{barcode\_prio}
Attributs nicht mit dem aus den beiden Attributen \texttt{anlage} und
\texttt{asset\_subnumber} generierten Barcode übereinstimmen. Um diese
Bedingung zu erfüllen kann nur die \texttt{validate\_unique()} Methode
herbeigezogen werden.

\hypertarget{das-htlroom-modell}{%
\subsection{Das HTLRoom Modell}\label{das-htlroom-modell}}

Das \texttt{HTLRoom}-Modell repräsentiert die Raumdaten der HTL Rennweg.
Es sind typische Merkmale aus dem \emph{SAP ERP}
\index{SAP ERP: Enterprise-Resource-Planning Software der Firma SAP. Damit können Unternehmen mehrere Bereiche wie beispielsweise Inventardaten oder Kundenbeziehungen zentral verwalten}
System vertreten. Die Attribute \texttt{room\_number},
\texttt{main\_inv} und \texttt{location} werden direkt aus dem
\emph{SAP ERP}
\index{SAP ERP: Enterprise-Resource-Planning Software der Firma SAP. Damit können Unternehmen mehrere Bereiche wie beispielsweise Inventardaten oder Kundenbeziehungen zentral verwalten}
System übernommen.

\hypertarget{die-wichtigsten-attribute-1}{%
\subsubsection{Die wichtigsten
Attribute}\label{die-wichtigsten-attribute-1}}

Zu den wichtigsten Attributen des \texttt{HTLRoom} Modells zählen u.a.:

\begin{itemize}
\tightlist
\item
  \texttt{room\_number}: Dieses Attribut bildet den Barcode eines
  Raumes.
\item
  \texttt{barcode\_override}: Wenn dieses Attribut gesetzt ist,
  überschreibt es den durch das Attribut \texttt{room\_number}
  gebildeten Barcode.
\item
  \texttt{internal\_room\_number}: Dieses Attribut repräsentiert die
  schulinterne Raumnummer und ist somit von den Daten aus dem
  \emph{SAP ERP}
  \index{SAP ERP: Enterprise-Resource-Planning Software der Firma SAP. Damit können Unternehmen mehrere Bereiche wie beispielsweise Inventardaten oder Kundenbeziehungen zentral verwalten}
  System unabhängig.
\item
  \texttt{is\_in\_sap}: Der Wert dieses
  \emph{Boolean}\index{Boolean: Ein Wert, der nur "Wahr" oder "Falsch" sein kann}-Attributs
  ist \texttt{Wahr}, wenn der \texttt{HTLRoom}-Datensatz einen aus dem
  \emph{SAP ERP}
  \index{SAP ERP: Enterprise-Resource-Planning Software der Firma SAP. Damit können Unternehmen mehrere Bereiche wie beispielsweise Inventardaten oder Kundenbeziehungen zentral verwalten}
  System vorhandenen Raum repräsentiert.
\item
  \texttt{children}: Mit dieser Beziehung können einem übergeordneten
  \texttt{HTLRoom} Objekt mehrere \texttt{HTLRoom} Objekte untergeordnet
  werden. Anwendungsfall für dieses Attribut ist die Definition von
  Schränken oder Serverracks, die je einem übergeordneten Raum zugeteilt
  sind, selbst aber eigenständige Räume repräsentieren.
\item
  \texttt{type}: Dieses Attribut spezifiziert die Art eines
  \texttt{HTLRoom} Objekts. So kann ein \texttt{HTLRoom} Objekt einen
  ganzen Raum oder auch nur einen Kasten in einem übergeordneten Raum
  repräsentieren.
\item
  \texttt{item}: Dieses Attribut kann gesetzt werden, um ein
  \texttt{HTLRoom} Objekt durch ein \texttt{HTLItem} Objekt zu
  repräsentieren. Anwendungsbeispiel ist ein Schrank, der sowohl als
  \texttt{HTLRoom} Objekt als auch als \texttt{HTLItem} Objekt definiert
  ist. Sind die beiden Objekte durch das \texttt{item} Attribut
  verbunden, ist der Barcode des \texttt{HTLRoom} Objekts automatisch
  jener des \texttt{HTLItem} Objekts.
\end{itemize}

\hypertarget{einzigartigkeit-von-htlroom-objekten}{%
\subsubsection{Einzigartigkeit von HTLRoom
Objekten}\label{einzigartigkeit-von-htlroom-objekten}}

Bezüglich der Einzigertigkeit von \texttt{HTLRoom} Objekten gelten
ähnliche Bestimmungen wie zu jener von \texttt{HTLItem} Objekten.

Die Attribute \texttt{room\_number}, \texttt{main\_inv} und
\texttt{location} sind gemeinsam einzigartig. Leere Werte sind von
dieser Regel ausgeschlossen. Gleichzeitig darf der Wert des
\texttt{barcode\_override} Attribut nicht mit dem Wert des
\texttt{room\_number} Attributes eines anderen \texttt{HTLRoom} Objekts
übereinstimmen und vice versa. Beide Bedingungen müssen wie im Falle des
\texttt{HTLItem} Modells durch Überschreiben der
\texttt{validate\_unique()}\footnote{Eine Methode einer Modell-Klasse,
  die unter Normalzuständen immer vor dem Speichern eines Objekts des
  Modells aufgerufen wird. Wirft sie einen Fehler auf, kann das Objekt
  nicht gespeichert werden.} Methode \cite{django-doku-models-instances}
implementiert werden.

\hypertarget{subruxe4ume}{%
\subsubsection{Subräume}\label{subruxe4ume}}

Wie im Abschnitt \protect\hyperlink{die-wichtigsten-attribute-1}{``Die
wichtigsten Attribute''} festgehalten, können einem \texttt{HTLRoom}
Objekt mehrere \texttt{HTLRoom} Objekte untergeordnet werden. Diese
untergeordneten Räume werden ``Subräume'' genannt. Bei ``Subräumen''
handelt es sich beispielsweise um einen Kasten, der als eigenständiger
Raum in einem ihm übergeordneten Raum steht. Logisch betrachtet ist der
Kasten auch nur ein Raum, in dem sich Gegenstände befinden. Ob der Raum
ein Klassenraum oder ein Kasten in einem Klassenraum ist, hat keine
logischen Auswirkungen auf seine Eigenschaften als ``Standort von
Gegenständen''.

Um eine valide Hierarchie beizubehalten, muss diese Beziehung bei jedem
Speicherprozess eines \texttt{HTLRoom} Objekts überprüft werden. Das
geschieht durch die Methode \texttt{clean\_children()}, die beim
Speichern durch die graphische Administrationsoberfläche automatisch
aufgerufen wird. Bei Speichervorgängen, die nicht direkt durch die
Administrationsoberfläche initiiert werden \footnote{etwa das
  automatisierte Speichern beim Datenimport}, muss
\texttt{clean\_children()} manuell aufgerufen werden.

\hypertarget{das-htlitemtype-modell}{%
\subsection{Das HTLItemType Modell}\label{das-htlitemtype-modell}}

Das \texttt{HTLItemType} Modell repräsentiert Kategorien von
Gegenständen. Das Modell besteht aus 2 Eigenschaften. Die Eigenschaft
\texttt{item\_type} beschreibt ein \texttt{HTLItemType} kurz, die
Eigenschaft \texttt{description} bietet Platz für Kommentare.

Durch das Setzen eines \texttt{HTLItemType} Objekts für ein
\texttt{HTLItem} Objekt durch seine Eigenschaft \texttt{item\_type}
werden dem \texttt{HTLItem} Objekt alle
\emph{Custom-Fields}\index{Custom-Fields: Benutzerdefinierte Eigenschaften eines Objektes in der Datenbank, die für jedes Objekt ünabhängig definierbar sind.}
des \texttt{HTLItemType} Objekts zugewiesen. Anwendungsbeispiel ist das
Setzen eines
\emph{Custom-Fields}\index{Custom-Fields: Benutzerdefinierte Eigenschaften eines Objektes in der Datenbank, die für jedes Objekt ünabhängig definierbar sind.}
namens ``Anzahl Ports'' für den \texttt{HTLItemType} namens ``Switch''.
Jedes \texttt{HTLItem} Objekt mit dem \texttt{item\_type} ``Switch'' hat
nun ein \emph{Custom-Field} namens ``Anzahl Ports''.

Das für
\emph{Custom-Fields}\index{Custom-Fields: Benutzerdefinierte Eigenschaften eines Objektes in der Datenbank, die für jedes Objekt ünabhängig definierbar sind.}
erforderliche Mixin (siehe Abschnitt
\protect\hyperlink{designgrundlagen}{``Designgrundlagen''})
\texttt{WithCustomFieldsMixin} bietet die Funktion der
\texttt{custom\_fields\_inheritance}. Die Funktion ermöglicht das Erben
von allen \emph{Custom-Field} Werten eines bestimmten Objekts an ein
anderes. Dieser Funktion macht sich das \texttt{HTLItem} Modell zunutze.
Um beim Speichern automatisch vom \texttt{HTLItemType} Objekt
unabhängige \emph{Custom-Field} Werte zu erstellen, die sofort vom
Benutzer bearbeitet werden können, muss der Speicherlogik eine Funktion
hinzugefügt werden. Dazu wird eine \texttt{@receiver} Methode genutzt,
die automatisch bei jedem Speichervorgang eines \texttt{HTLItemType}
oder \texttt{HTLItem} Objekts aufgerufen wird:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{@receiver}\NormalTok{(post\_save, sender}\OperatorTok{=}\NormalTok{HTLItemType)}
\KeywordTok{def}\NormalTok{ populate\_htlitem\_custom\_field\_values(sender, instance, }\OperatorTok{**}\NormalTok{kwargs):}
\NormalTok{    populate\_inheritants\_custom\_field\_values(instance)}
    
\AttributeTok{@receiver}\NormalTok{(post\_save, sender}\OperatorTok{=}\NormalTok{HTLItem)}
\KeywordTok{def}\NormalTok{ populate\_htlitemtype\_custom\_field\_values(sender, instance, }\OperatorTok{**}\NormalTok{kwargs):}
\NormalTok{    populate\_with\_parents\_custom\_field\_values(instance)}
\end{Highlighting}
\end{Shaded}

Die beiden angeführten Methoden werden je beim Aufkommen eines
\texttt{post\_save} Signals \cite{django-doku-signals} ausgeführt,
dessen \texttt{sender} ein \texttt{HTLItemType} oder \texttt{HTLItem}
ist. Die Methoden rufen jeweils eine weitere Methode auf, welche die
\emph{Custom-Fields} entsprechend aggregiert.

\hypertarget{datenimport}{%
\subsection{Datenimport}\label{datenimport}}

Um die Gegenstands- und Raumdaten des Inventars der HTL Rennweg in das
erstellte System importieren zu können, muss dessen standardmäßig
verfügbare Importfunktion entsprechend erweitert werden. Dazu sind 4
spezielle Importverhalten notwendig.

Implementiert wird das Importverhalten nicht innerhalb der
entsprechenden Modellklasse, sondern in dessen verknüpften
\texttt{ModelAdmin} Klasse. Durch das Attribut \texttt{resource\_class}
wird spezifiziert, durch welche Python-Klasse die Daten importiert
werden. Um für ein einziges Modell mehrere \texttt{resource\_class}
Einträge zu setzen, müssen mehrere \texttt{ModelAdmin} Klassen für
Proxy-Modelle \cite{django-doku-models} des eigentlichen Modells
definiert werden. Ein Proxy-Modell eines Modells verweist auf dieselbe
Tabelle in der Datenbank, kann aber programmiertechnisch als
unabhängiges Modell betrachtet werden. Die Daten, die durch das
Proxy-Modell ausgelesen oder eingefügt werden entsprechen exakt jenen
des eigentlichen Modells.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Definition eines Proxy{-}Modells zu dem Modell "HTLItem"}
\KeywordTok{class}\NormalTok{ HTLItemSecondaryImportProxy(HTLItem):}
    \KeywordTok{class}\NormalTok{ Meta:}
\NormalTok{        proxy }\OperatorTok{=} \VariableTok{True}

\CommentTok{\# Diese Datenbankabfragen liefern beide dasselbe Ergebnis:}
\BuiltInTok{print}\NormalTok{(HTLItem.objects.}\BuiltInTok{all}\NormalTok{())}
\BuiltInTok{print}\NormalTok{(HTLItemSecondaryImportProxy.objects.}\BuiltInTok{all}\NormalTok{())}

\CommentTok{\# Für das Proxy{-}Modell kann eine ModelAdmin{-}Klasse definiert werden.}
\CommentTok{\# Diese bekommt eine eigene "resource\_class".}
\AttributeTok{@register}\NormalTok{(HTLItemSecondaryImportProxy)}
\KeywordTok{class}\NormalTok{ HTLItemSecondaryImportProxyAdmin(HTLItemSecondaryImportMixin, RalphAdmin):}
\NormalTok{    resource\_class }\OperatorTok{=}\NormalTok{ HTLItemSecodaryResource}
\end{Highlighting}
\end{Shaded}

Das Importverhalten wird in der Klasse, die in das Attribut
\texttt{resource\_class} eingetragen wird, programmiertechnisch
festgelegt. Es werden alle Zeilen der zu importierenden Datei
nacheinander abgearbeitet. Bei sehr großen Datenmengen oder aufwändigem
Importverhalten kann es zu Performanceverlusten kommen. Da nahezu jedes
durch das Diplomarbeitsteam erstellte Importverhalten die zu
importierenden Daten überprüfen oder anderweitig speziell behandeln
muss, kann es hier besonders zu Performanceengpässen kommen.
Beispielsweise muss beim Import von Daten aus dem \emph{SAP ERP}
\index{SAP ERP: Enterprise-Resource-Planning Software der Firma SAP. Damit können Unternehmen mehrere Bereiche wie beispielsweise Inventardaten oder Kundenbeziehungen zentral verwalten}
System auch geprüft werden, ob der Raum eines Gegenstandes existiert.
Die oft sehr großen Datenmengen, die aus dem \emph{SAP ERP}
\index{SAP ERP: Enterprise-Resource-Planning Software der Firma SAP. Damit können Unternehmen mehrere Bereiche wie beispielsweise Inventardaten oder Kundenbeziehungen zentral verwalten}
System importiert werden müssen, sorgen ebenfalls für
Performanceverluste.

Die in den zu importierenden Dateien vorhandenen Überschriften werden
vor dem Importprozess auf Modelleigenschaften abgebildet. Manche Werte
der zu importierenden Datensätze müssen in Werte gewandelt werden, die
in der Datenbank gespeichert werden können. In der Datei
\texttt{import\_settings.py} sind diese Abbildungen bzw. Umwandlungen
als ``\emph{Aliases} \index{Alias: ein Pseudonym}'' deklariert. In dem
folgenden Beispiel werden die Überschriften ``Erstes Attribut'' und
``Zweites Attribut'' auf die zwei Modelleigenschaften \texttt{field\_1}
und \texttt{field\_2} abgebildet. Importierte Werte für ``Zweites
Attribut'' werden von den Zeichenketten ``Ja'' und ``Nein'' auf die
\emph{Boolean}\index{Boolean: Ein Wert, der nur "Wahr" oder "Falsch" sein kann}-Werte
\texttt{True} und \texttt{False} übersetzt.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Beispielhafte Definition von Aliases für einen Import}
\NormalTok{ALIASES\_HTLITEM }\OperatorTok{=}\NormalTok{ \{}
    \StringTok{"field\_1"}\NormalTok{: ([}\StringTok{"Erstes Attribut"}\NormalTok{], \{}

\NormalTok{    \}),}
    \StringTok{"field\_2"}\NormalTok{: ([}\StringTok{"Zweites Attribut"}\NormalTok{], \{}
      \StringTok{"Ja"}\NormalTok{: }\VariableTok{True}\NormalTok{,}
      \StringTok{"Nein"}\NormalTok{: }\VariableTok{False}
\NormalTok{    \}),}
\end{Highlighting}
\end{Shaded}

Der Datenimport wird immer zweimal durchlaufen. Zuerst werden die
importierten Daten zwar generiert, aber nicht gespeichert und dem
Benutzer nur zur Validierung vorgelegt. Nach einer Bestätigung des
Benutzers werden die Daten ein weiteres Mal von Neuem generiert und
gespeichert.

Informationen über das Format einer zu importierenden Quelldatei ist dem
\todo{Add reference} Handbuch zum Server zu entnehmen.

\hypertarget{import-aus-dem-sap-erp-system}{%
\subsubsection{Import aus dem SAP ERP
System}\label{import-aus-dem-sap-erp-system}}

Die Daten aus dem \emph{SAP ERP}
\index{SAP ERP: Enterprise-Resource-Planning Software der Firma SAP. Damit können Unternehmen mehrere Bereiche wie beispielsweise Inventardaten oder Kundenbeziehungen zentral verwalten}
System der Schule können in ein gängiges Datenformat exportiert werden.
Das üblich gewählte Format ist eine Excel-Tabelle (Dateiendung
``\texttt{.xlsx}'').

Die aus dem \emph{SAP ERP}
\index{SAP ERP: Enterprise-Resource-Planning Software der Firma SAP. Damit können Unternehmen mehrere Bereiche wie beispielsweise Inventardaten oder Kundenbeziehungen zentral verwalten}
System exportierten Daten haben grundsätzlich immer volle Gültigkeit.
Bereits im ``Capentory'' System vorhandene Daten werden überschrieben.

Zu importierende Datensätze werden anhand der Werte ``BuKr'', ``Anlage''
und ``UNr.'' aus der Quelldatei verglichen. Diese Werte werden auf die
\texttt{HTLItem} Modellattribute \texttt{company\_code}, \texttt{anlage}
und \texttt{asset\_subnumber} abgebildet. Zusätzlich wird auch das
\texttt{barcode\_prio} Attribut mit dem zusammengefügten Wert der
``Anlage'' und ``UNr.'' Felder \footnote{Diese Felder repräsentieren den
  Barcode eines \texttt{HTLItem} Objekts.} der Quelldatei verglichen.
Stimmt ein \texttt{HTLItem} Datensatz aus dem ``Capentory'' System mit
einem zu importierenden Datensatz aufgrund einer der beiden verglichenen
Wertepaare überein, wird dieser damit assoziiert und überschrieben.

Vor dem Verarbeiten der Daten des \texttt{HTLItem} Objekts werden die
Daten des zugehörigen \texttt{HTLRoom} Objekts verarbeitet. Es wird nach
einem existierenden \texttt{HTLRoom} Objekt mit einem übereinstimmenden
\texttt{room\_number} Attribut\footnote{Das ``Raum'' Feld der Quelldatei
  wird auf das \texttt{room\_number} Attribut abgebildet.} gesucht.
Sollten mehrere \texttt{HTLRoom} Objekte übereinstimmen\footnote{Dieser
  Fall sollte bei einem einzigen Schulstandort nicht auftreten.}, wird
jener mit übereinstimmenden \texttt{main\_inv} und \texttt{location}
Attributen \footnote{Die ``Hauptinven'' und ``Standort'' Felder der
  Quelldatei werden auf die \texttt{main\_inv} und \texttt{location}
  Attribute abgebildet.} ausgewählt. Ein gefundenes \texttt{HTLRoom}
Objekt wird mit dem importierten \texttt{HTLItem} Objekt verknüpft.
Sollte kein \texttt{HTLRoom} Objekt gefunden werden, wird es mit den
entsprechenden Werten erstellt. In beiden Fällen wird das
\texttt{is\_in\_sap}
\emph{Boolean}\index{Boolean: Ein Wert, der nur "Wahr" oder "Falsch" sein kann}-Attribut
des \texttt{HTLRoom} Objekts gesetzt.

Es gibt eine Ausnahme der absoluten Gültigkeit der Daten aus dem
\emph{SAP ERP}
\index{SAP ERP: Enterprise-Resource-Planning Software der Firma SAP. Damit können Unternehmen mehrere Bereiche wie beispielsweise Inventardaten oder Kundenbeziehungen zentral verwalten}
System. Stimmt das gefundene \texttt{HTLRoom} Objekt nicht mit jenem
aktuell verknüpften \texttt{HTLRoom} Objekt eines \texttt{HTLItem}
Objekts überein, wird es grundsätzlich aktualisiert. Sollte das aktuell
verknüpfte \texttt{HTLRoom} Objekt ein ``Subraum'' des gefundenen
Objekts sein, wird dieses nicht aktualisiert. So wird verhindert, dass
Gegenstände durch den Import aus einem Subraum in den übergeordneten
Raum wandern. In dem \emph{SAP ERP}
\index{SAP ERP: Enterprise-Resource-Planning Software der Firma SAP. Damit können Unternehmen mehrere Bereiche wie beispielsweise Inventardaten oder Kundenbeziehungen zentral verwalten}
System existieren die ``Subräume'' grundsätzlich nicht.

\hypertarget{import-aus-sekunduxe4rer-und-tertiuxe4rer-quelle}{%
\subsubsection{Import aus sekundärer und tertiärer
Quelle}\label{import-aus-sekunduxe4rer-und-tertiuxe4rer-quelle}}

Bei der sekundären und tertiären Quelle handelt es sich um schulinterne
Inventarlisten. Beide Quellen enthalten Informationen über den Raum, in
dem sich ein bestimmter Gegenstand befindet. Die sekundäre Quelle
enthält Informationen über die Kategorie eines EDV-spezifischen
Gegenstands. Die tertiäre Quelle enthält Informationen über ``Subräume''
und welche Gegenstände sich darin befinden.

Beide Quellen besitzen allerdings keine absolute Gültigkeit wie der
Import aus dem \emph{SAP ERP}
\index{SAP ERP: Enterprise-Resource-Planning Software der Firma SAP. Damit können Unternehmen mehrere Bereiche wie beispielsweise Inventardaten oder Kundenbeziehungen zentral verwalten}
System. Aus diesem Grund werden alle Änderungen von Eigenschaften eines
\texttt{HTLItem} Objekts in Änderungsvorschläge einer Inventur
ausgelagert und nicht direkt angewendet. Die Änderungen können zu einem
späteren Zeitpunkt eingesehen, bearbeitet und schlussendlich angewendet
werden. Grund für dieses spezielle Importverhalten ist die
Vertrauenswürdigkeit der Informationen, die der sekundären bzw.
tertiären Quelle entnommen werden. Die Listen haben offiziell kein
einheitliches Format und können daher bei sofortigem Übernehmen der
Änderungen zu ungewollten Fehlinformationen führen. Der Import einer
sekundären oder tertiären Quelle kann wie eine eigenständige Inventur
angesehen werden. Es können durch den Import auch neue \texttt{HTLItem}
Objekte hinzugefügt werden, wenn ein Datensatz mit keinem bestehenden
Objekt assoziiert werden kann.

Das Importverhalten für die sekundäre Quelle erstellt zusätzlich durch
die Methode \texttt{get\_or\_create\_item\_type()} der Klasse
\texttt{HTLItemSecodaryResource} definierte \texttt{HTLItemType}
Objekte. Die erstellten \texttt{HTLItemType} Objekte werden den
\texttt{HTLItem} Objekten indirekt über Änderungsvorschläge zugewiesen.

Die bereits erwähnten Informationen über ``Subräume'' der tertiären
Quelle werden sofort auf die entsprechenden \texttt{HTLRoom} Objekte
angewendet. Es bedarf keiner weiteren Bestätigung, um die ``Subräume''
zu erstellen und den übergeordneten \texttt{HTLRoom} Objekten
zuzuweisen.

\hypertarget{import-der-raumliste}{%
\subsubsection{Import der Raumliste}\label{import-der-raumliste}}

Die Importfunktion der Raumliste dient zur Verlinkung von interner
Raumnummer (\texttt{HTLRoom}-Attribut \texttt{internal\_room\_number})
und der Raumnummer im \emph{SAP ERP}
\index{SAP ERP: Enterprise-Resource-Planning Software der Firma SAP. Damit können Unternehmen mehrere Bereiche wie beispielsweise Inventardaten oder Kundenbeziehungen zentral verwalten}
System (\texttt{HTLRoom}-Attribut \texttt{room\_number}). Es werden
dadurch bestehenden \texttt{HTLRoom} Objekten eine interne Raumnummer
und eine Beschreibung zugewiesen, oder gänzlich neue \texttt{HTLRoom}
Objekte anhand aller erhaltenen Informationen erstellt. Der Import
geschieht direkt, ohne Auslagerung von Änderungen in
Änderungsvorschläge.

\hypertarget{das-stocktaking-modul}{%
\section{Das ``Stocktaking'' Modul}\label{das-stocktaking-modul}}

Das ``\emph{Stocktaking}'' \index{Stocktaking: Inventur} Modul
ermöglicht das Erstellen und Verwalten von Inventuren. Um das
Datenbankmodell möglichst modular und übersichtlich zu gestalten, werden
diverse Modelle miteinander hierarchisch verknüpft. Die oberste Ebene
der Modellhierarchie bildet das \texttt{Stocktaking} Modell. In der
Abbildung \ref{fig:stocktaking_klassendiagramm} ist die Hierarchie in
Form eines Klassendiagramms abgebildet. Das Klassendiagramm wurde
mithilfe der Erweiterungen \texttt{django\_extensions} und
\texttt{pygraphviz} erstellt. Folgendes Kommando wurde dafür aufgerufen
\cite{django-graph-models}:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{dev\_ralph}\NormalTok{ graph\_models stocktaking \textbackslash{}}
\NormalTok{{-}X ItemSplitChangeProposal,MultipleValidationsChangeProposal,}
   \ExtensionTok{ValueChangeProposal}\NormalTok{,TimeStampMixin \textbackslash{}}
\NormalTok{{-}g {-}o stocktaking\_klassendiagramm.png}
\end{Highlighting}
\end{Shaded}

Um die
\emph{Subklassen}\index{Subklasse: Eine programmiertechnische Klasse, die eine übergeordnete Klasse, auch "Superklasse", erweitert oder verändert, indem sie alle Attribute und Methoden der Superklasse erbt}
der Klasse \texttt{ChangeProposalBase} auszublenden, wurden diese mit
der Option \texttt{-X} exkludiert.

\begin{figure}
  \includegraphics[width=\linewidth]{stocktaking_klassendiagramm.png}
  \caption{Das automatisch generierte Klassendiagramm der Modelle des "Stocktaking" Moduls.}
  \label{fig:stocktaking_klassendiagramm}
\end{figure}

\hypertarget{das-stocktaking-modell}{%
\subsection{Das Stocktaking Modell}\label{das-stocktaking-modell}}

Eine Inszanz des \texttt{Stocktaking} Modells repräsentiert eine
Inventur.

\hypertarget{die-wichtigsten-attribute-2}{%
\subsubsection{Die wichtigsten
Attribute}\label{die-wichtigsten-attribute-2}}

Zu den wichtigsten Attributen des \texttt{Stocktaking} Modells zählen
u.a.:

\begin{itemize}
\tightlist
\item
  \texttt{name}: Durch dieses Attribut kann eine Inventur benannt
  werden. Dieser Name erscheint auf der mobilen Applikation oder dem
  Inventurbericht.
\item
  \texttt{user}: Dieses Attribut referenziert einen
  Hauptverantwortlichen Benutzer einer Inventur.
\item
  \texttt{date\_started} und \texttt{time\_started}: Diese Attribute
  sind Zeitstempel und werden automatisch auf den Zeitpunkt der
  Erstellung einer \texttt{Stocktaking} Instanz gesetzt. Eine Inventur
  beginnt zum Zeitpunkt ihrer Erstellung.
\item
  \texttt{date\_finished} und \texttt{time\_finished}: Diese Attribute
  sind Zeitstempel und werden gesetzt, wenn ein Administrator eine
  Inventur beenden möchte. Wenn beide Attribute mit einem Wert befüllt
  sind, werden keine über die mobile Applikation empfangene
  Validierungen verarbeitet. Der Zeitpunkt, der sich aus den beiden
  Attributen ergibt, darf nicht vor dem Zeitpunkt aus
  \texttt{date\_started} und \texttt{time\_started} liegen.
\item
  \texttt{neverending\_stocktaking}: Wenn dieses
  \emph{Boolean}\index{Boolean: Ein Wert, der nur "Wahr" oder "Falsch" sein kann}
  Attribut gesetzt ist, hat der Wert der \texttt{date\_finished} und
  \texttt{time\_finished} Attribute keine Bedeutung. Es werden alle
  Validierungen der mobilen Applikation verarbeitet. Ob in einem Raum
  bereits einmal validiert wurde oder die Inventur beendet ist, wird
  nicht mehr überprüft.
\end{itemize}

\hypertarget{das-stocktakinguseractions-modell}{%
\subsection{Das StocktakingUserActions
Modell}\label{das-stocktakinguseractions-modell}}

Das \texttt{StocktakingUserActions} Modell ist die Verbindung zwischen
einer Inventur und den Benutzern, die zu dieser Inventur beigetragen
haben. Das Attribut \texttt{stocktaking} verlinkt je eine bestimmte
\texttt{Stocktaking} Instant. Das Attribut \texttt{user} verlinkt je
eine bestimmte \texttt{RalphUser} Instanz, die einem angemeldeten
Benutzer entspricht. Validierungen, die ein Benutzer während einer
Inventur tätigt, sind mit der entsprechenden
\texttt{StocktakingUserActions} Instanz verknüpft. Pro Inventur kann es
nur eine \texttt{StocktakingUserActions} Instanz für einen bestimmten
Benutzer geben. Diese Bedingung wird durch die \texttt{unique\_together}
Metavariable \cite{django-doku-models-options} festgelegt:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{unique\_together }\OperatorTok{=}\NormalTok{ [[}\StringTok{"user"}\NormalTok{, }\StringTok{"stocktaking"}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\hypertarget{das-stocktakingroomvalidation-modell}{%
\subsection{Das StocktakingRoomValidation
Modell}\label{das-stocktakingroomvalidation-modell}}

Das \texttt{StocktakingRoomValidation} Modell ist die Verbindung
zwischen einer \texttt{StocktakingUserActions} Instanz und einer
bestimmten Raum-Instanz. Die Raum-Instanz kann dank der
\texttt{GenericForeignKey} Funktionalität
\cite{django-doku-contenttypes} von jedem beliebigen Modell stammen. In
der Implementierung einer Client-Schnittstelle wird ein konkretes Modell
spezifiziert. Zum Zweck der Inventur an der HTL Rennweg ist das
\texttt{HTLRoom} Modell in der entsprechenden Client-Schnittstelle
spezifiziert. Eine Instanz des \texttt{StocktakingRoomValidation}
Modells repräsentiert das Validieren von Gegenständen in einem
bestimmten Raum.

\hypertarget{das-stocktakingitem-modell}{%
\subsection{Das StocktakingItem
Modell}\label{das-stocktakingitem-modell}}

Das \texttt{StocktakingItem} Modell repräsentiert die Validierung einer
Gegenstands-Instanz während einer Inventur. Die Gegenstands-Instanz kann
dank der \texttt{GenericForeignKey} Funktionalität
\cite{django-doku-contenttypes} von jedem beliebigen Modell stammen. In
der Implementierung einer Client-Schnittstelle wird ein konkretes Modell
spezifiziert. Zum Zweck der Inventur an der HTL Rennweg ist das
\texttt{HTLItem} Modell in der entsprechenden Client-Schnittstelle
spezifiziert. Durch die Beziehungen zu den Modellen
\texttt{StocktakingRoomValidation} und dadurch zu
\texttt{StocktakingUserActions} und \texttt{Stocktaking} ist erkennbar,
in welchem Raum durch welchen Benutzer im Rahmen welcher Inventur ein
Gegenstand validiert wurde. Durch das \texttt{ChangeProposalBase} Modell
sind die Änderungsvorschläge einer Gegenstandsvalidierung verknüpft.

\hypertarget{die-wichtigsten-attribute-3}{%
\subsubsection{Die wichtigsten
Attribute}\label{die-wichtigsten-attribute-3}}

Zu den wichtigsten Attributen des \texttt{StocktakingItem} Modells
zählen u.a.:

\begin{itemize}
\tightlist
\item
  \texttt{date\_validated} und \texttt{time\_validated}: Diese Attribute
  bilden den Zeitstempel der Gegenstandsvalidierung. Durch die
  Client-Schnittstelle erstellten \texttt{StocktakingItem} Instanzen
  wird der Wert der aktuellen Systemzeit zum Zeitpunkt des Datenempfangs
  zugewiesen. Wird ein Gegenstand mehrmals validiert\footnote{Dieser
    Fall tritt bei Inventuren auf, dessen
    \texttt{neverending\_stocktaking} Attribut gesetzt ist. So kann
    derselbe Gegenstand Monate nach der ersten Validierung erneut
    während derselben Inventur validiert werden.}, ist der Zeitstempel
  jener der jüngsten Validierung.
\item
  \texttt{mark\_for\_later\_validation}: Dieses
  \emph{Boolean}\index{Boolean: Ein Wert, der nur "Wahr" oder "Falsch" sein kann}
  Attribut dient zur erleichterten Verifikation der Validierungen durch
  einen Administrator. Ist das Attribut gesetzt, repräsentiert es eine
  unvertrauenswürdige Gegenstandsvalidierung. Das Attribut wird gesetzt,
  wenn der Benutzer durch die mobile Applikation angibt, sich bei einer
  Gegenstandsvalidierung nicht sicher zu sein und daher das ``Später
  entscheiden'' Feld setzt. Innerhalb des Inventur-Berichts werden
  \texttt{StocktakingItem} Instanzen, dessen
  \texttt{mark\_for\_later\_validation} Attribut gesetzt ist, besonders
  markiert.
\end{itemize}

\hypertarget{uxe4nderungsvorschluxe4ge}{%
\subsection{Änderungsvorschläge}\label{uxe4nderungsvorschluxe4ge}}

Änderungsvorschläge beziehen sich auf eine bestimmte
\texttt{StocktakingItem} Instanz. Ein Änderungsvorschlag ist eine
Instanz einer
\emph{Subklasse}\index{Subklasse: Eine programmiertechnische Klasse, die eine übergeordnete Klasse, auch "Superklasse", erweitert oder verändert, indem sie alle Attribute und Methoden der Superklasse erbt}
von \texttt{ChangeProposalBase}. Ein Änderungsvorschlag besagt, dass der
aktuelle Zustand eines Datensatzes in der Datenbank nicht der Realität
entspricht.

Um während einer Inventur nicht sofort jegliche erkannte Änderungen von
Gegenstandseigenschaften anwenden zu müssen, werden sie in
Änderungsvorschläge ausgelagert. So kann Fehlern, die während einer
Inventur entstehen können, vorgebeugt werden. Dem Benutzer der mobilen
Applikation wird dadurch Vertrauenswürdigkeit entzogen. Es ist die
Aufgabe eines Administrators, Änderungsvorschläge als vertrauenswürdig
einzustufen und diese tatsächlich anzuwenden.

Als Basis für Änderungsvorschläge dient die Klasse
\texttt{ChangeProposalBase}. Sie beschreibt nicht, welche Änderung
während einer Inventur festgestellt wurde. Sie erbt von der Klasse
\texttt{Polymorphic}. Die Klasse \texttt{Polymorphic} ermöglicht die
Vererbung von Modellklassen auf der Datenbankebene. So können alle
\emph{Subklassen}\index{Subklasse: Eine programmiertechnische Klasse, die eine übergeordnete Klasse, auch "Superklasse", erweitert oder verändert, indem sie alle Attribute und Methoden der Superklasse erbt}
der Klassen \texttt{ChangeProposalBase} einheitlich betrachtet werden.
Über die Verbindung von \texttt{StocktakingItem} zu
\texttt{ChangeProposalBase} in der Abbildung
\ref{fig:stocktaking_klassendiagramm} sind nicht nur alle verknüpften
\texttt{ChangeProposalBase} Instanzen, sondern auch alle Instanzen der
\emph{Subklassen}\index{Subklasse: Eine programmiertechnische Klasse, die eine übergeordnete Klasse, auch "Superklasse", erweitert oder verändert, indem sie alle Attribute und Methoden der Superklasse erbt}
von \texttt{ChangeProposalBase}, verbunden. Eine
\emph{Subklassen}\index{Subklasse: Eine programmiertechnische Klasse, die eine übergeordnete Klasse, auch "Superklasse", erweitert oder verändert, indem sie alle Attribute und Methoden der Superklasse erbt}
von \texttt{ChangeProposalBase} beschreibt eine Änderung, die von einem
Benutzer während einer Inventur festgestellt würde. Es sind 4
\emph{Subklassen}\index{Subklasse: Eine programmiertechnische Klasse, die eine übergeordnete Klasse, auch "Superklasse", erweitert oder verändert, indem sie alle Attribute und Methoden der Superklasse erbt}
von \texttt{ChangeProposalBase} und damit 4 Arten von
Änderungsvorschlägen implementiert:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \texttt{ValueChangeProposal}
\item
  \texttt{MultipleValidationsChangeProposal}
\item
  \texttt{ItemSplitChangeProposal}
\item
  \texttt{SAPExportChangeProposal}
\end{enumerate}

Weitere Informationen über die Arten von Änderungsvorschlägen und deren
Handhabung sind dem \todo{Add reference} Handbuch zum Server zu
entnehmen.

\hypertarget{die-client-schnittstelle}{%
\subsection{Die Client-Schnittstelle}\label{die-client-schnittstelle}}
