\chapter{Einführung in die Server-Architektur}

Die Inventur- sowie Gegenstandsdaten der HTL Rennweg sollen an einem
zentralen Ort verwaltet und geführt werden. Der für diesen Zweck
entwickelte Server muss also folgende Anforderungen erfüllen:

\begin{itemize}
\tightlist
\item
  eine einfache Datenbankverwaltung und -verbindung
\item
  das Führen einer Historie aller Zustände der Inventar-Gegenstände
\item
  eine Grundlage für eine Web-Administrationsoberfläche
\item
  die Möglichkeit für Datenimport und -export, etwa als
  \emph{.xlsx}\index{.xlsx: Format einer Excel Datei} Datei
\item
  eine Grundlage für die Kommunikation mit der Client-Applikation
\item
  hohe Stabilität und Verfügbarkeit
\end{itemize}

Angesichts der Programmiersprachen, in die das Projektteam spezialisiert
ist, stehen als Backend-Lösung vier
\emph{Frameworks}\index{Framework: Eine softwaretechnische Architektur, die bestimmte Funktionen und Klassen zur Verfügung stellt}
zur öffentlichen Verfügung, zwischen denen gewählt wurde:

\begin{itemize}
\tightlist
\item
  Django \cite{django}
\item
  Pyramid \cite{pyramid}
\item
  Web2Py \cite{web2py}
\item
  Flask \cite{flask}
\end{itemize}

Alle genannten Alternativen sind
\emph{Frameworks}\index{Framework: Eine softwaretechnische Architektur, die bestimmte Funktionen und Klassen zur Verfügung stellt}
der Programmiersprache Python. Gewählt wurde ``Django'' aufgrund einer
bestehenden und frei verfügbaren Inventarverwaltungsplattform ``Ralph''
\cite{ralph}, welche auf Django aufbaut und durch die vorliegende
Diplomarbeit hinreichend erweitert wird.

\hypertarget{django-und-ralph}{%
\section{Django und Ralph}\label{django-und-ralph}}

Django ist ein in der Programmiersprache Python geschriebenes
Webserver-\emph{Framework}\index{Framework: Eine softwaretechnische Architektur, die bestimmte Funktionen und Klassen zur Verfügung stellt}.
Ralph ist eine auf dem
Django-\emph{Framework}\index{Framework: Eine softwaretechnische Architektur, die bestimmte Funktionen und Klassen zur Verfügung stellt}
basierende
\emph{DCIM}\index{DCIM: Data Center Infrastructure Management - Software, die zur Verwaltung von Rechenzentren entwickelt wird }
und
\emph{CMDB}\index{CMDB: Configuration Management Database - Eine Datenbank, die für die Konfiguration von IT-Geräten entwickelt ist \cite{cmdb}}
Softwarelösung. Haupteinsatzgebiet dieser Software sind vor allem
Rechenzentren mit hoher Komplexität, die externe Verwaltungsplattformen
benötigen. Zusätzlich können aber auch herkömmliche Inventardaten von
IT-spezifischen Gegenständen in die Ralph-Plattform aufgenommen werden.

Ralph wurde von der polnischen Softwarefirma ``Allegro'' entwickelt und
ist unter der Apache 2.0 Lizenz öffentlich verfügbar. Dies ermöglicht
auch Veränderungen und Erweiterungen. Zu Demonstrationszwecken bietet
Allegro eine öffentlich nutzbare Demo-Version \cite{ralph-demo} von
Ralph an.

Die vorliegende Diplomarbeit bietet eine Erweiterung des Ralph-Systems.

\hypertarget{begruxfcndung-der-wahl-von-django-und-ralph}{%
\subsection{Begründung der Wahl von Django und
Ralph}\label{begruxfcndung-der-wahl-von-django-und-ralph}}

Django bietet eine weit verbreitete Open-Source Lösung für die
Entwicklung von Web-Diensten. Bekannte Webseiten, die auf Django
basieren sind u.a. Instagram, Mozilla, Pinterest und Open Stack.
\cite{django-overview} Django zeichnet sich besonders durch die sog.
\emph{"Batteries included"}\index{Batteries included: Das standardmäßige Vorhandensein von erwünschten bzw. gängigen \emph{Features}\index{Feature: Eigenschaft bzw. Funktion eines Systems}, zu Deutsch: Batterien einbezogen}
Mentalität aus. Das heißt, dass Django bereits die gängigsten
\emph{Features}\index{Feature: Eigenschaft bzw. Funktion eines Systems}
eines Webserver-Backends standardmäßig innehat. Diese sind (im Vergleich
zu Alternativen wie etwa ``Flask'') u.a.:

\begin{itemize}
\tightlist
\item
  Authentifikation und Autorisierung, sowie eine damit verbundene
  Benutzerverwaltung
\item
  Schutz vor gängigen Attacken (wie
  \emph{SQL-Injections}\index{SQL-Injections: klassischer Angriff auf ein Datenbanksystem}
  oder
  \emph{CSRF}\index{CSRF: Cross-Site-Request-Forgery - eine Angriffsart, bei dem ein Opfer dazu gebracht wird, eine von einem Angreifer gefälschte Anfrage an einen Server zu schicken \cite{csrf}}\cite{csrf}),
  siehe \protect\hyperlink{views}{Views}
\end{itemize}

Zusätzlich bietet Ralph bereits einige
\emph{Features}\index{Feature: Eigenschaft bzw. Funktion eines Systems},
die die grundlegende Führung und Verwaltung eines herkömmlichen
Inventars unterstützen (beispielsweise eine Suchfunktion mit
automatischer Textvervollständigung).

\hypertarget{kurzfassung-der-funktionsweise-von-django-und-rlaph}{%
\section{Kurzfassung der Funktionsweise von Django und
Rlaph}\label{kurzfassung-der-funktionsweise-von-django-und-rlaph}}

Im folgenden Kapitel wird die Funktionsweise des
Django-\emph{Frameworks}\index{Framework: Eine softwaretechnische Architektur, die bestimmte Funktionen und Klassen zur Verfügung stellt},
sowie Ralph beschrieben. Ziel dieses Kapitels ist es, eine Wissensbasis
für die darauffolgenden Kapitel zu schaffen.

\hypertarget{datenbank-verbindung-pakete-und-tabellen-definition}{%
\subsection{Datenbank-Verbindung, Pakete und
Tabellen-Definition}\label{datenbank-verbindung-pakete-und-tabellen-definition}}

Folgende Datenbank-Typen werden von Django unterstützt:

\begin{itemize}
\tightlist
\item
  PostgreSQL
\item
  MariaDB
\item
  MySQL
\item
  Oracle
\item
  SQLite
\end{itemize}

Die Konfiguration der Datenbank-Verbindung geschieht unter
Standard-Django in der Datei \texttt{settings.py} , unter Ralph in der
jeweiligen Datei im Verzeichnis \texttt{settings}. Eine detaillierte
Anleitung zur Verbindung mit einer Datenbank ist in der offiziellen
Django-Dokumentation \cite{django-doku-db} zu finden.

Die verschiedenen Funktionsbereiche des Servers sind in Pakete bzw.
Module gegliedert. Jedes Paket ist ein Ordner, der verschiedene Dateien
und Unterordner beinhalten kann. Die Dateinamen-Nomenklatur eines
Packets ist normiert.\cite{django-file-nomenklatur} Der Name eines
Pakets wird fortan ``App-Label'' genannt. Standardmäßig ist dieser Name
erster Bestandteil einer URL zu einer beliebigen grafischen
Administrationsoberfläche des Pakets. Pakete werden durch einen Eintrag
in die Variable \texttt{INSTALLED\_APPS} innerhalb der o.a.
Einstellungsdatei registriert. Beispiele sind die beiden durch die
vorliegende Diplomarbeit registrierten Pakete \texttt{"ralph.capentory"}
und \texttt{"ralph.stocktaking"}

Ist ein Python-Paket erfolgreich registriert, können in der Datei
\texttt{models.py} Datenbank-Tabellen als python Klassen\footnote{erbend
  von der Superklasse \texttt{Model}\cite{django-doku-models}} definiert
werden. Diese Klassen werden fortan als ``Modell'' bezeichnet.
Tabellenattribute werden als Attribute dieser Klassen definiert und sind
jeweils Instanzen der Klasse
\texttt{Field}\cite{django-doku-models}\footnote{oder davon erbende
  Klassen}. Datenbankeinträge können demnach als Instanzen der
Modellklassen betrachtet und behandelt werden. Standardmäßig besitzt
jedes Modell ein Attribut \texttt{id}, welches als
\emph{primärer Schlüssel}\index{primärer Schlüssel: engl. "primary key", abgek. "pk" - ein Attribut, das einen Datensatz eindeutig identifiziert}
dient. Der Wert des \texttt{id} Attributs ist unter allen Instanzen
eines Modells einzigartig. Die Anpassung dieses Attributs wird in der
offiziellen Django-Dokumentation genauer behandelt.
\cite{django-doku-models}

Jedes Modell benötigt eine innere Klasse \texttt{Meta}. Sie beschreibt
die
\emph{Metadaten}\index{Metadaten: Daten, die einen gegebenen Datensatz beschreiben, beispielsweise der Autor eines Buches}
der Modellklasse. Dazu gehört vor allem der von Benutzern lesbare Name
des Modells \texttt{verbose\_name}. \cite{django-doku-models-options}

\hypertarget{administration-uxfcber-das-webinterface}{%
\subsection{Administration über das
Webinterface}\label{administration-uxfcber-das-webinterface}}

Um die Administration von Modelldaten über das Webinterface des Servers
zu ermöglichen, werden grundsätzlich zwei Ansichten der Daten benötigt:
Eine Listenansicht aller Datensätze und eine Detailansicht einzelner
Datensätze.

Die Listenansicht aller Datensätze eines Modells wird in der Datei
\texttt{admin.py} als
\emph{Subklasse}\index{Subklasse: Eine programmiertechnische Klasse, die eine übergeordnete Klasse, auch "Superklasse", erweitert oder verändert, indem sie alle Attribute und Methoden der Superklasse erbt}
von \texttt{ModelAdmin}\footnote{Unter Ralph steht hierfür die Klasse
  \texttt{RalphAdmin} zur Verfügung.\cite{ralph-admin-doku}} definiert.
Attribute dieser Klasse beeinflussen das Aussehen und die Funktionsweise
der Weboberfläche. Durch das Setzen von \texttt{list\_display} werden
beispielsweise die in der Liste anzuzeigenden Attribute definiert.

Die Detailansicht einzelner Datensätze wird grundsätzlich durch die
\texttt{ModelAdmin} Klasse automatisch generiert, kann aber durch Setzen
dessen \texttt{form} Attributs auf eine eigens definierte
\emph{Subklasse}\index{Subklasse: Eine programmiertechnische Klasse, die eine übergeordnete Klasse, auch "Superklasse", erweitert oder verändert, indem sie alle Attribute und Methoden der Superklasse erbt}
von \texttt{ModelForm}\footnote{Unter Ralph steht hierfür die Klasse
  \texttt{RalphAdminForm} zur Verfügung.} angepasst werden. Diese
Klassen werden in der Datei \texttt{forms.py} definiert und besitzen,
ähnlich der \texttt{Model} Klasse, auch eine innere Klasse
\texttt{Meta}.

Um die \texttt{ModelAdmin}
\emph{Subklassen}\index{Subklasse: Eine programmiertechnische Klasse, die eine übergeordnete Klasse, auch "Superklasse", erweitert oder verändert, indem sie alle Attribute und Methoden der Superklasse erbt}
über eine URL erreichbar zu machen, müssen diese registriert werden.
Dies geschieht durch den \texttt{register}
\emph{Dekorator}\index{Dekorator: Fügt unter Python einer Klasse oder Methode eine bestimmte Funktionsweise hinzu \cite{python-decorators}}.
Dieser Dekorator akzeptiert die zu registrierende Modellklasse, die zu
dem \texttt{ModelAdmin} gehört, als Parameter. Die Listenansicht einer
registrierten \texttt{ModelAdmin} Subklasse ist standardmäßig unter der
URL

\begin{verbatim}
/<App-Label>/<Modell-Name>/
\end{verbatim}

erreichbar, die Detailansicht einer Modellinstanz unter der URL

\begin{verbatim}
/<App-Label>/<Modell-Name>/<Modellinstanz-ID>/
\end{verbatim}

. Somit repräsentiert die URL der Listenansicht gleichzeitig den Pfad,
unter der sie definiert wurde.

Die Dokumentation der Administrationsfeatures von Django ist auf der
offiziellen Dokumentationswebseite von Django \cite{django-doku-admin}
zu finden.

\hypertarget{api-und-drf}{%
\subsection{API und DRF}\label{api-und-drf}}

Um Daten außerhalb der grafischen Administrationsoberfläche zu
bearbeiten, wird eine
\emph{API}\index{API: Application-Programming-Interface - Eine Schnittstelle, die die programmiertechnische Erstellung, Bearbeitung und Einholung  von Daten auf einem System ermöglicht}
benötigt. Eine besondere und weit verbreitete Form einer API ist eine
\emph{REST-API}
\index{REST-API: Representational State Transfer \emph{API}\index{API: Application-Programming-Interface - Eine Schnittstelle, die die programmiertechnische Erstellung, Bearbeitung und Einholung  von Daten auf einem System ermöglicht} - eine zustandslose Schnittstelle für den Datenaustausch zwischen Clients und Servern \cite{rest-api}}
\cite{rest-api}, die unter Django durch das integrierte
\emph{DRF}\index{DRF: Django REST Framework - Implementierung einer \emph{REST-API}\index{REST-API: Representational State Transfer \emph{API}\index{API: Application-Programming-Interface - Eine Schnittstelle, die die programmiertechnische Erstellung, Bearbeitung und Einholung  von Daten auf einem System ermöglicht} - eine zustandslose Schnittstelle für den Datenaustausch zwischen Clients und Servern \cite{rest-api}} unter Django \cite{django-rest-framework}}
implementiert wird.\cite{django-rest-framework} API Definitionen werden
unter Django in einem Paket in der Datei \texttt{api.py} getätigt.

Um den API-Zugriff auf ein Modell zu ermöglichen werden üblicherweise
eine \texttt{APIView}\footnote{Unter Ralph steht hierfür die Klasse
  \texttt{RalphAPISerializer} zur Verfügung. \cite{ralph-api-doku}}
\emph{Subklasse}\index{Subklasse: Eine programmiertechnische Klasse, die eine übergeordnete Klasse, auch "Superklasse", erweitert oder verändert, indem sie alle Attribute und Methoden der Superklasse erbt}
und eine \texttt{Serializer}\footnote{Unter Ralph steht hierfür die
  Klasse \texttt{RalphAPIViewSet} zur Verfügung. \cite{ralph-api-doku}}
\emph{Subklasse}\index{Subklasse: Eine programmiertechnische Klasse, die eine übergeordnete Klasse, auch "Superklasse", erweitert oder verändert, indem sie alle Attribute und Methoden der Superklasse erbt}
definiert. \texttt{APIView} Klassen sind zuständig für das Abarbeiten
von Anfragen mithilfe einer \texttt{Serializer} Klasse, die die Daten
aus der Datenbank repräsentiert und in das gewünschte Format
konvertiert. Durch \texttt{APIView} Klassen werden Berechtigungen und
sonstige Attribute definiert, die sich auf das wahrgenommene
Erscheinungsbild des Servers auf einen Client auswirken. Beispiel dafür
ist die Art der \emph{Paginierung}
\cite{django-rest-framework}\index{Paginierung: engl. pagination - Die Aufteilung von Datensätzen in diskrete Seiten \cite{django-rest-framework-pagination}}.
Die erstellten \texttt{APIView} Klassen können dann mithilfe einer
\texttt{Router}\footnote{Unter Ralph steht hierfür die globale
  \texttt{RalphRouter} Instanz \texttt{router} zur Verfügung.
  \cite{ralph-api-doku}} Instanz registriert werden. Anleitungen zur
Erstellung dieser API-Klassen sind auf der offiziellen Webseite des DRF
\cite{django-rest-framework} und der offiziellen
Ralph-Dokumentationsseite \cite{ralph-api-doku} zu finden.

\hypertarget{views}{%
\subsection{Views}\label{views}}

Schnittstellen, die keiner der beiden o.a. Kategorien zugeordnet werden
können, werden in der Datei \texttt{views.py} definiert. Bei diesen
\emph{generischen}\index{generisch: in einem allgemeingültigen Sinn}
Schnittstellen handelt es sich entweder um
\emph{Subklassen}\index{Subklasse: Eine programmiertechnische Klasse, die eine übergeordnete Klasse, auch "Superklasse", erweitert oder verändert, indem sie alle Attribute und Methoden der Superklasse erbt}
der Klasse \texttt{View}\footnote{die ebenfalls Superklasse der Klasse
  \texttt{ApiView} ist} \cite{django-doku-class-based-views} oder
vereinzelte Methoden mit einem \texttt{request}\footnote{zu Deutch:
  Anfrage; entspricht dem empfangenen Packet, meist als HTML.}
Parameter. \cite{django-doku-views} Diese Schnittstellen werden fortan
Views genannt.

Soll ein View als Antwort auf eine Anfrage HTML-Daten liefern, so sollte
dazu ein \emph{Template}\index{Template: zu Deutch: Vorlage, Schablone}
verwendet werden. Mithilfe von Templates können Daten, die etwa durch
Datenbankabfrage entstehen, zu einer HTML Antwort aufbereitet werden.
Besonders ist hierbei die zusätzlich zu HTML verfügbare
Django-Template-\emph{Syntax}\index{Syntax: Regelwerk, sprachliche Einheiten miteinander zu verknüpfen \cite{syntax}}
\cite{django-doku-template}. Damit können HTML Elemente auf den
Input-Daten basierend dynamisch generiert werden. So stehen
beispielsweise \texttt{if} Statements direkt in der Definition des
Templates zur Verfügung. Die Benutzung von Templates schützt
standardmäßig gegen gängige Attacken, wie
\emph{SQL-Injections}\index{SQL-Injections: klassischer Angriff auf ein Datenbanksystem}
oder \emph{CSRF}
\index{CSRF: Cross-Site-Request-Forgery - eine Angriffsart, bei dem ein Opfer dazu gebracht wird, eine von einem Angreifer gefälschte Anfrage an einen Server zu schicken \cite{csrf}}\cite{csrf}
und gilt daher als besonders sicher.

Da reguläre Views nicht automatisch registriert werden, müssen sie
manuell bekanntgegeben werden. Dies geschieht durch einen Eintrag in die
Variable \texttt{urlpatterns} in der Datei \texttt{urls.py}.
\cite{django-doku-urls}

\hypertarget{datenbankabfragen}{%
\subsection{Datenbankabfragen}\label{datenbankabfragen}}

Datenbankabfragen werden in Django durch \texttt{Queryset}-Objekte
getätigt. Das Definieren eines \texttt{Queryset}-Objekts löst nicht
sofort eine Datenbankabfrage aus. Erst, wenn Werte aus einem
\texttt{Queryset}-Objekt gelesen werden, wird eine Datenbankabfrage
ausgelöst. So kann ein \texttt{Queryset}-Objekt beliebig oft verändert
werden, bevor davon ausgelesen wird. Ein Beispiel hierfür ist das
Anwenden der \texttt{filter()} Methode.

In dem folgenden Code-Auszug\footnote{entnommen aus der offiziellen
  Django Dokumentation \cite{django-doku-queries}} werden aus dem Modell
\texttt{Entry} bestimmte Einträge gefiltert:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Erstelle ein Queryset aller Entry{-}Objekte, }
\CommentTok{\# dessen Attribut "headline" mit "What" beginnt.}
\NormalTok{q }\OperatorTok{=}\NormalTok{ Entry.objects.}\BuiltInTok{filter}\NormalTok{(headline\_\_startswith}\OperatorTok{=}\StringTok{"What"}\NormalTok{)}

\CommentTok{\# Filtere aus dem erstellten Queryset alle Entry{-}Objekte, }
\CommentTok{\# dessen Attribut "pub\_date" kleiner oder gleich }
\CommentTok{\# dem aktuellen Datum ist.}
\NormalTok{q }\OperatorTok{=}\NormalTok{ q.}\BuiltInTok{filter}\NormalTok{(pub\_date\_\_lte}\OperatorTok{=}\NormalTok{datetime.date.today())}

\CommentTok{\# Schließe aus dem erstellten Queryset alle Entry{-}Objekte, }
\CommentTok{\# dessen Attribut "body\_text" den Text "food" beinhaltet, aus.}
\NormalTok{q }\OperatorTok{=}\NormalTok{ q.exclude(body\_text\_\_icontains}\OperatorTok{=}\StringTok{"food"}\NormalTok{)}

\CommentTok{\# Ausgabe des erstellten Querysets.}
\CommentTok{\# Erst hier kommt es zu der ersten Datenbankabfrage!}
\BuiltInTok{print}\NormalTok{(q)}
\end{Highlighting}
\end{Shaded}

Weitere Beispiele und Methoden sind der offiziellen Django-Dokumentation
zu entnehmen. \cite{django-doku-queries}

\hypertarget{designgrundlagen}{%
\section{Designgrundlagen}\label{designgrundlagen}}

Designgrundlagen für Django-Entwickler sind auf der offiziellen
Dokumentationsseite von Django abrufbar. \cite{django-doku-coding-style}
Die Erweiterung von Django durch die vorliegende Diplomarbeit wurde
anhand dieser Grundlagen entwickelt.

Das Konzept des \texttt{Mixin}s wird von der Ralph-Plattform besonders
häufig genutzt. \texttt{Mixin}s sind Klassen, die anderen von ihnen
erbende Klassen, bestimmte Attribute und Methoden hinzufügen. Manche
\texttt{Mixin}s setzen implizit voraus, dass die davon erbenden Klassen
ebenfalls von bestimmten anderen Klassen erben. Beispiel ist die Klasse
\texttt{AdminAbsoluteUrlMixin}, welche eine Methode
\texttt{get\_absolute\_url} zur Verfügung stellt. Diese Methode liefert
die URL, die zu der Detailansicht der Modellinstanz führt, die die
Methode aufruft. Voraussetzung für das Erben einer Klasse von
\texttt{AdminAbsoluteUrlMixin} ist daher, dass sie ebenfalls von der
Klasse \texttt{Model} erbt.

\chapter{Die 2 Erweiterungsmodule}

Die vorliegende Diplomarbeit erweitert das
\protect\hyperlink{django-und-ralph}{``Ralph''} System um 2 Module.
Dabei handelt es sich um die beiden Pakete ``Capentory'' und
``Stocktaking''. Das Paket ``Capentory'' behandelt die Führung der
Inventurdaten und wurde speziell an die Inventardaten der HTL Rennweg
angepasst.. Das Paket ``Stocktaking'' ermöglicht die Verwaltung der
durch die mobile Applikation durchgeführten Inventuren. Dazu zählen
Aufgaben wie das Erstellen der Inventuren, das Einsehen von
Inventurberichten oder das Anwenden der aufgetretenen Änderungen.

Dieses Kapitel beschreibt die Funktionsweise der beiden Module. Die
Bedienung der \emph{Weboberfläche}
\index{Weboberfläche: graphische Oberfläche für administrative Tätigkeiten, die über einen Webbrowser erreichbar ist}
ist dem \todo{Add reference} Handbuch zum Server zu entnehmen.

\hypertarget{das-capentory-modul}{%
\section{Das ``Capentory'' Modul}\label{das-capentory-modul}}

Das ``Capentory'' Modul beherbergt 3 wichtige Modelle:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  HTLItem
\item
  HTLRoom
\item
  HTLItemType
\end{enumerate}

Die wichtigsten Eigenschaften der Modelle und damit verbundenen
Funktionsweisen werden in diesem Unterkapitel beschrieben

\hypertarget{htlitem}{%
\subsection{HTLItem}\label{htlitem}}

Das \texttt{HTLItem}-Modell repräsentiert die Gegenstandsdaten des
Inventars der HTL Rennweg. Es sind typische Merkmale aus dem
\emph{SAP ERP}
\index{SAP ERP: Enterprise-Resource-Planning Software der Firma SAP. Damit können Unternehmen mehrere Bereiche wie beispielsweise Inventardaten oder Kundenbeziehungen zentral verwalten}
System sind vertreten. Die Attribute \texttt{anlage},
\texttt{asset\_subnumber} und \texttt{company\_code} werden direkt aus
dem \emph{SAP ERP}
\index{SAP ERP: Enterprise-Resource-Planning Software der Firma SAP. Damit können Unternehmen mehrere Bereiche wie beispielsweise Inventardaten oder Kundenbeziehungen zentral verwalten}
System übernommen.

\hypertarget{die-wichtigsten-attribute}{%
\subsubsection{Die wichtigsten
Attribute}\label{die-wichtigsten-attribute}}

Zu den wichtigsten Attributen des \texttt{HTLItem} Modells zählen u.a.:

\begin{itemize}
\tightlist
\item
  \texttt{anlage} und \texttt{asset\_subnummer}: Diese Attribute bilden
  den Barcode eines Gegenstandes
\item
  \texttt{barcode\_prio}: Wenn dieses Attribut gesetzt ist, überschreibt
  es den durch die Attribute \texttt{anlage} und
  \texttt{asset\_subnummer} entstandenen Barcode.
\item
  \texttt{anlagenbeschreibung}: Dieses Attribut repräsentiert die aus
  dem \emph{SAP ERP}
  \index{SAP ERP: Enterprise-Resource-Planning Software der Firma SAP. Damit können Unternehmen mehrere Bereiche wie beispielsweise Inventardaten oder Kundenbeziehungen zentral verwalten}
  System entnommene Gegenstandsbeschreibung und kann nur durch den
  Import von Daten direkt aus dem \emph{SAP ERP}
  \index{SAP ERP: Enterprise-Resource-Planning Software der Firma SAP. Damit können Unternehmen mehrere Bereiche wie beispielsweise Inventardaten oder Kundenbeziehungen zentral verwalten}
  System geändert werden.
\item
  \texttt{anlagenbeschreibung\_prio}: Dieses Attribut dient als interne
  Gegenstandsbeschreibung, die auch ohne einen Import aus dem
  \emph{SAP ERP}
  \index{SAP ERP: Enterprise-Resource-Planning Software der Firma SAP. Damit können Unternehmen mehrere Bereiche wie beispielsweise Inventardaten oder Kundenbeziehungen zentral verwalten}
  System geändert werden kann.
\item
  \texttt{room}: Dieses Attribut referenziert auf das \texttt{HTLRoom}
  Objekt, in dem sich ein \texttt{HTLItem} Objekt befindet.
\item
  \texttt{is\_in\_sap}: Der Wert dieses
  \emph{Boolean}\index{Boolean: Ein Wert, der nur "Wahr" oder "Falsch" sein kann}-Attribut
  ist \texttt{Wahr}, wenn der \texttt{HTLItem}-Datensatz aus dem
  \emph{SAP ERP}
  \index{SAP ERP: Enterprise-Resource-Planning Software der Firma SAP. Damit können Unternehmen mehrere Bereiche wie beispielsweise Inventardaten oder Kundenbeziehungen zentral verwalten}
  System importiert wurde. Umgekehrt ist der Wert dieses Attributes
  \texttt{Falsch}, wenn der \texttt{HTLItem}-Datensatz aus einer anderen
  Quelle entstanden ist. Ein manuell hinzugefügter
  \texttt{HTLItem}-Datensatz hat für dieses Attribut den Wert
  \texttt{Falsch}.
\item
  \texttt{item\_type}: Dieses Attribut referenziert auf das
  \texttt{HTLItemType} Objekt, welches einem \texttt{HTLItem} Objektes
  zugeordnet ist. Es repräsentiert die Gegenstandskategorie eines
  \texttt{HTLItem} Objektes.
\end{itemize}

\hypertarget{einzigartigkeit-von-htlitem-objekten}{%
\subsubsection{Einzigartigkeit von HTLItem
Objekten}\label{einzigartigkeit-von-htlitem-objekten}}

Bezüglich der Einzigartigkeit von \texttt{HTLItem} Objekten gelten
folgende Bestimmungen
